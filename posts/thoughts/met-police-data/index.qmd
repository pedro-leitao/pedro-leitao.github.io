---
title: Metropolitan Police Data
subtitle: what is going on in london ?
tags:
  - Thoughts
  - Publishing
  - Open Data
categories:
  - Thoughts
  - Open Data
  - London
date: 2025-04-19
---

London has historically been a city which isn't a complete stranger to crime. Here I provide a compilation of visuals produced from available [open data](https://data.police.uk) regarding London crime as reported by the Metropolitan Police. I include no comentary on it, and restric myself to derived visuals and the code to produce them. This crime data is exclusively as reported, and is not a complete picture as there is also *unreported* crime, which obviously is not included in this dataset. All charts are interactive, and you can hover over them to see more details.

This includes *incomplete* data for 2025.

```{python}
#| echo: false
#| output: false
# Recursively load all data under /home/pedro/datasets/met-police-data/, find files named *metropolitan-street.csv and add them to a single Pandas DataFrame
import os
import pandas as pd
import glob

files = glob.glob('/home/pedro/datasets/met-police-data/**/*metropolitan-street.csv', recursive=True)
print(f"Found {len(files)} files.")
dataframes = []
for file in files:
    df = pd.read_csv(file)
    dataframes.append(df)
# Concatenate all dataframes into a single dataframe
df = pd.concat(dataframes, ignore_index=True)
```

```{python}
#| echo: false
#| output: false
# Convert Month column to datetime
df['Month'] = pd.to_datetime(df['Month'], format='%Y-%m')
df['Year'] = df['Month'].dt.year
# Calculate earliest and latest date
earliest_date = df['Month'].min()
latest_date = df['Month'].max()
```

```{python}
#| echo: false
#| output: false
# Extract borough from 'LSOA name', matching 'borough xxxx'
df['Borough'] = df['LSOA name'].str.extract(r'(((\w|\s)+)\s(\d|\w)+$)', expand=False)[1]
```

```{python}
#| echo: false
#| output: false
df.head()
```

```{python}
#| echo: false
#| output: false
# Set a plotly template
import plotly.io as pio
pio.templates.default = "simple_white"
```

## Totals and trends

Overall totals and trends, including the number of crimes per month, cumulative totals over time, and the peak month for each crime type.

### Number of crimes per month and three-month moving average
```{python}
import plotly.express as px

df['count'] = 1
df_grouped = df.groupby('Month').count().reset_index()
df_grouped['three_month_avg'] = df_grouped['count'].rolling(3).mean()

fig = px.line(
    df_grouped,
    x='Month',
    y=['count', 'three_month_avg'],
    labels={'value': 'Number of Crimes', 'variable': 'Series'}
)

fig.update_traces(line=dict(width=2), mode='lines')

fig.update_layout(
    xaxis_title='Month',
    yaxis_title='Number of Crimes',
    title_x=0.5,
    title_y=0.95,
    title_font=dict(size=18),
    xaxis_tickformat='%Y-%m',
    xaxis_tickangle=-45,
    legend=dict(
        orientation='h',    # horizontal legend
        yanchor='bottom',
        y=1.02,             # slightly above the plot
        xanchor='center',
        x=0.5
    ),
    margin=dict(t=80)      # add top margin so legend doesn't overlap
)

fig.show()
```

### Cummulative totals over time
```{python}
import plotly.graph_objects as go

df_bars = df.copy()
df_bars['Month'] = pd.to_datetime(df_bars['Month'])
df_bars['Month_str'] = df_bars['Month'].dt.strftime('%Y-%m')

df_group = (
    df_bars
    .groupby(['Month_str', 'Crime type'])
    .size()
    .reset_index(name='count')
)
df_group['Month_dt'] = pd.to_datetime(df_group['Month_str'])
df_group = df_group.sort_values('Month_dt')
df_group['cumcount'] = df_group.groupby('Crime type')['count'].cumsum()

months = df_group['Month_str'].unique().tolist()
max_cum = df_group['cumcount'].max()

frames = []
for m in months:
    dfm = df_group[df_group['Month_str']==m].sort_values('cumcount', ascending=False)
    frames.append(go.Frame(
        data=[go.Bar(x=dfm['Crime type'], y=dfm['cumcount'])],
        layout=go.Layout(xaxis=dict(categoryarray=dfm['Crime type'].tolist())),
        name=m
    ))

df0 = df_group[df_group['Month_str']==months[0]].sort_values('cumcount', ascending=False)

fig = go.Figure(
    data=[go.Bar(x=df0['Crime type'], y=df0['cumcount'])],
    frames=frames,
    layout=go.Layout(
        margin=dict(b=220),  # extra bottom space
        xaxis=dict(
            title='Crime Type',
            tickangle=-45,
            categoryorder='array',
            categoryarray=df0['Crime type'].tolist()
        ),
        yaxis=dict(title='Cumulative Count', range=[0, max_cum*1.1]),
        updatemenus=[{
            'type': 'buttons',
            'showactive': False,
            'x': 0.0,
            'y': -0.5,            # lower than slider
            'xanchor': 'left',
            'yanchor': 'top',
            'buttons': [{
                'label': '▶️ Play',
                'method': 'animate',
                'args': [None, {
                    'frame': {'duration': 500, 'redraw': True},
                    'fromcurrent': True,
                    'transition': {'duration': 300, 'easing': 'linear'}
                }]
            }]
        }],
        sliders=[{
            'active': 0,
            'pad': {'t': 60, 'b': 10},
            'len': 0.8,
            'x': 0.1,
            'y': -0.3,             # sit below x‑labels
            'xanchor': 'left',
            'yanchor': 'top',
            'currentvalue': {'prefix': 'Month: ', 'visible': True},
            'transition': {'duration': 300, 'easing': 'linear'},
            'steps': [
                {
                    'label': m,
                    'method': 'animate',
                    'args': [[m], {
                        'frame': {'duration': 500, 'redraw': True},
                        'mode': 'immediate'
                    }]
                } for m in months
            ]
        }]
    )
)

fig.show()
```

### Peak month for each crime type
```{python}
df['MonthName'] = df['Month'].dt.month_name()

# count per crime/month
df_monthly = (
    df
    .groupby(['Crime type', 'MonthName'])
    .size()
    .reset_index(name='count')
)

# pick worst month for each crime
idx = df_monthly.groupby('Crime type')['count'].idxmax()
worst_months = df_monthly.loc[idx].sort_values('count', ascending=False)

# plot with bars in descending order
fig = px.bar(
    worst_months,
    x='Crime type',
    y='count',
    color='MonthName',
    text='MonthName',
    category_orders={'Crime type': worst_months['Crime type'].tolist()}
)

fig.update_traces(
    marker=dict(line=dict(width=2)),
    textposition='outside'
)

fig.update_layout(
    xaxis_title='Crime Type',
    yaxis_title='Occurrences in Peak Month',
    title_x=0.5,
    title_y=0.95,
    title_font=dict(size=18),
    xaxis_tickangle=-45,
    legend_title_text='Worst Month',
    legend=dict(
        orientation='h',
        yanchor='bottom',
        y=1.02,
        xanchor='center',
        x=0.5
    ),
    margin=dict(t=100)
)

fig.show()
```

### Number of crimes per month by type
You can click on the legend to hide or show a crime type, and double-click to isolate a crime type.
```{python}

df_grouped = df.groupby(['Month', 'Crime type']) \
               .count() \
               .reset_index()

fig = px.area(
    df_grouped,
    x='Month',
    y='count',
    color='Crime type'
)

# thicken the lines on the boundaries between areas
fig.update_traces(line=dict(width=2), mode='lines')

# move the legend above the chart
fig.update_layout(
    xaxis_title='Month',
    yaxis_title='Number of Occurrences',
    title_x=0.5,
    title_y=0.95,
    title_font=dict(size=18),
    xaxis_tickformat='%Y-%m',
    xaxis_tickangle=-45,

    legend=dict(
        orientation='h',
        yanchor='bottom',
        y=1.02,
        xanchor='center',
        x=0.5
    ),
    margin=dict(t=100)
)

fig.show()
```

## Changes year-on-year

Changes, relative to the same month in the previous year.

### Crime type, per month
```{python}

monthly = (
    df
    .groupby(['Crime type','Month'], as_index=False)['count']
    .sum()
)
monthly['prev_month'] = monthly['Month'] - pd.DateOffset(years=1)

prev = (
    monthly[['Crime type','Month','count']]
    .rename(columns={'Month':'prev_month','count':'prev_count'})
)
merged = monthly.merge(prev, on=['Crime type','prev_month'], how='left')
merged['pct_change'] = (merged['count'] - merged['prev_count']) \
                       / merged['prev_count'] * 100
plot_df = merged.dropna(subset=['prev_count']).copy()

plot_df['Trend'] = plot_df['pct_change'].apply(lambda x: 'Rising' if x >= 0 else 'Decreasing')
plot_df['Month'] = pd.to_datetime(plot_df['Month'])

fig = px.bar(
    plot_df,
    x='Month',
    y='pct_change',
    color='Crime type',
    facet_row='Trend',
    category_orders={'Trend': ['Rising', 'Decreasing']},
    labels={'pct_change':'% change'}
)

fig.add_hline(y=0, line_dash='dash', line_color='gray', row='all', col='all')

fig.update_layout(
    xaxis=dict(tickformat='%Y‑%m', tickangle=-45),
    bargap=0.2,

    # move legend above the plot
    legend=dict(
        orientation='h',
        yanchor='bottom',
        y=1.02,
        xanchor='center',
        x=0.5
    ),
    margin=dict(t=100),
    legend_title_text=''
)

fig.for_each_annotation(lambda a: a.update(text=a.text.split('=')[-1]))

fig.show()
```

### Crime type, per month (top 3 risers and fallers)
```{python}

mean_change = plot_df.groupby('Crime type')['pct_change'].mean()
top_risers  = mean_change.nlargest(3).index.tolist()
top_fallers = mean_change.nsmallest(3).index.tolist()

df_change = plot_df[plot_df['Crime type'].isin(top_risers + top_fallers)].copy()
df_change['Trend'] = df_change['Crime type'].apply(
    lambda ct: 'Rising' if ct in top_risers else 'Decreasing'
)
df_change['Month'] = pd.to_datetime(df_change['Month'])

fig = px.bar(
    df_change,
    x='Month',
    y='pct_change',
    color='Crime type',
    facet_row='Trend',
    category_orders={'Trend': ['Rising', 'Decreasing']},
    labels={'pct_change': '% change'}
)

fig.add_hline(y=0, line_dash='dash', line_color='gray', row='all', col='all')

fig.update_layout(
    xaxis=dict(tickformat='%Y-%m', tickangle=-45),
    bargap=0.2,
    legend=dict(
        orientation='h',
        yanchor='bottom',
        y=1.02, 
        xanchor='center',
        x=0.5
    ),
    margin=dict(t=100),
    legend_title_text=''
)

fig.for_each_annotation(lambda a: a.update(text=a.text.split('=')[-1]))

fig.show()
```

## Geographical heatmaps

You can zoom in and out, and pan around the map. The heatmap shows the density of crimes in a given month, down to individual crimes at street level.

### All crimes
```{python}
import folium
from folium.plugins import HeatMapWithTime

def generate_heatmap(df, crime_type=None):
    """
    Generate heatmap data for visualisation.

    Parameters:
    - df (pd.DataFrame): The input dataframe containing crime data.
    - crime_type (str, list, or None): The crime type(s) to filter by. If None, includes all crime types.

    Returns:
    - heat_data (list): Heatmap data for visualisation.
    - time_index (list): List of time indices for the heatmap.
    - centre (list): Latitude and longitude for the map's center.
    """
    df_map = df.copy()

    # Filter by crime type if specified
    if crime_type:
        if isinstance(crime_type, list):
            df_map = df_map[df_map['Crime type'].isin(crime_type)]
        else:
            df_map = df_map[df_map['Crime type'] == crime_type]

    # Filter out rows with missing coordinates
    df_map = df_map.dropna(subset=['Latitude', 'Longitude'])

    # Create a string label for each month
    df_map['Month_str'] = df_map['Month'].dt.strftime('%Y-%m')

    agg = (
        df_map
        .groupby(['Month_str', 'Latitude', 'Longitude'])
        .size()
        .reset_index(name='wt')
    )

    time_index = sorted(agg['Month_str'].unique())
    heat_data = [
        agg[agg['Month_str'] == m][['Latitude', 'Longitude', 'wt']].values.tolist()
        for m in time_index
    ]

    centre = [df['Latitude'].mean(), df['Longitude'].mean()]
    return heat_data, time_index, centre

heat_data, time_index, centre = generate_heatmap(df, crime_type=None)

m = folium.Map(location=centre, zoom_start=12, tiles='Cartodb Positron')

HeatMapWithTime(
    data=heat_data,
    index=time_index,
    auto_play=False,
    max_opacity=0.6,
    radius=7,
    gradient={0.1:'green', 0.4: 'blue', 0.7: 'lime', 1: 'red'}
).add_to(m)

m.save('crime_heatmap.html')
```

<iframe src="crime_heatmap.html" width="100%" height="450px"></iframe>

### Drug-related
```{python}

heat_data, time_index, centre = generate_heatmap(df, crime_type='Drugs')

m = folium.Map(location=centre, zoom_start=12, tiles='Cartodb Positron')

HeatMapWithTime(
    data=heat_data,
    index=time_index,
    auto_play=False,
    max_opacity=0.6,
    radius=7,
    gradient={0.1:'green', 0.4: 'blue', 0.7: 'lime', 1: 'red'}
).add_to(m)

m.save('crime_drugs_heatmap.html')
```

<iframe src="crime_drugs_heatmap.html" width="100%" height="450px"></iframe>

### Shoplifting
```{python}

heat_data, time_index, centre = generate_heatmap(df, crime_type='Shoplifting')

m = folium.Map(location=centre, zoom_start=12, tiles='Cartodb Positron')

HeatMapWithTime(
    data=heat_data,
    index=time_index,
    auto_play=False,
    max_opacity=0.6,
    radius=7,
    gradient={0.1:'green', 0.4: 'blue', 0.7: 'lime', 1: 'red'}
).add_to(m)

m.save('crime_shoplifting_heatmap.html')
```

<iframe src="crime_shoplifting_heatmap.html" width="100%" height="450px"></iframe>

### Violence and sexual offences
```{python}

heat_data, time_index, centre = generate_heatmap(df, crime_type='Violence and sexual offences')
m = folium.Map(location=centre, zoom_start=12, tiles='Cartodb Positron')
HeatMapWithTime(
    data=heat_data,
    index=time_index,
    auto_play=False,
    max_opacity=0.6,
    radius=7,
    gradient={0.1:'green', 0.4: 'blue', 0.7: 'lime', 1: 'red'}
).add_to(m)

m.save('crime_violence_heatmap.html')
```

<iframe src="crime_violence_heatmap.html" width="100%" height="450px"></iframe>

## Crime outcomes

Overall outcomes of crimes, as reported by the Metropolitan Police. Some outcomes might not be final, and are subject to change.

### Cummulative totals

```{python}

df['Last outcome category'] = df['Last outcome category'].fillna('Category N/A')

df_outcomes = (
    df['Last outcome category']
      .value_counts()
      .reset_index()
)
df_outcomes.columns = ['Outcome', 'Count']
df_outcomes = df_outcomes.sort_values('Count', ascending=False)

total = df_outcomes['Count'].sum()
df_outcomes['Pct'] = df_outcomes['Count'] / total * 100

fig = px.bar(
    df_outcomes,
    x='Outcome',
    y='Count',
    text='Pct',
    category_orders={'Outcome': df_outcomes['Outcome'].tolist()}
)

fig.update_traces(
    marker=dict(line=dict(width=2)),
    texttemplate='%{text:.1f}%',
    textposition='outside'
)

fig.update_layout(
    xaxis_title='Outcome',
    yaxis_title='Occurrences',
    title_x=0.5,
    title_y=0.95,
    title_font=dict(size=18),
    xaxis_tickangle=-45,
    yaxis_type='log'
)

fig.show()
```

### Outcomes month by month
```{python}

df_outcomes = df[['Month', 'Last outcome category']].dropna().copy()
df_outcomes['count'] = 1
df_outcomes_grouped = (
    df_outcomes
    .groupby(['Month', 'Last outcome category'], as_index=False)
    .count()
)

# Build the area plot
fig = px.area(
    df_outcomes_grouped,
    x='Month',
    y='count',
    color='Last outcome category',
    labels={'count': 'Number of Occurrences'}
)

fig.update_traces(line=dict(width=2), mode='lines')

fig.update_layout(
    xaxis_title='Month',
    yaxis_title='Number of Occurrences',
    title_x=0.5,
    title_y=0.95,
    title_font=dict(size=18),
    xaxis_tickformat='%Y-%m',
    xaxis_tickangle=-45,

    legend=dict(
        orientation='h',
        yanchor='bottom',
        y=1.02,
        xanchor='center',
        x=0.5
    ),
    margin=dict(t=100)
)

fig.show()
```

## Boroughs

Crime and outcomes relative to the location where it occurs.

### Location relative to crime type (top locations only)

This chart shows the relative percentage of each crime type for each location, i.e., the percentage of each crime type in the top N locations, relative to the total number of crimes in that location. This is useful to see which crime types are more prevalent in each location.
```{python}

n_locations = 20

# 1) aggregate raw counts
df_borough = (
    df
    .groupby(['Borough', 'Crime type'])
    .size()
    .reset_index(name='count')
)

# 2) pick top N boroughs by overall crime
top_locations = (
    df_borough
    .groupby('Borough')['count']
    .sum()
    .nlargest(n_locations)
    .index
    .tolist()
)
df_borough = df_borough[df_borough['Borough'].isin(top_locations)]

# 3) compute relative % **within each crime type**
df_borough['rel_pct'] = (
    df_borough
    .groupby('Crime type')['count']
    .transform(lambda x: x / x.sum() * 100)
)

# 4) lock in ordering
borough_order = top_locations
crime_order   = df_borough['Crime type'].unique().tolist()

# 5) plot
fig = px.density_heatmap(
    df_borough,
    x='Borough',
    y='Crime type',
    z='rel_pct',
    histfunc='sum',    # sums the one value per cell → rel_pct
    category_orders={
        'Borough': borough_order,
        'Crime type': crime_order
    },
    color_continuous_scale=['green', 'yellow', 'red'],
    labels={'rel_pct': '% of Crime Type'}
)

# 6) layout tweaks
fig.update_layout(
    xaxis_title='Borough',
    yaxis_title='Crime Type',
    title_x=0.5,
    title_y=0.95,
    title_font=dict(size=18),
)
fig.update_xaxes(tickangle=-45)

# 7) format colorbar ticks as percentages
fig.update_coloraxes(colorbar_tickformat=".1f")

fig.show()
```

## Location relative to outcome (top locations only)

```{python}

df_borough = (
    df
    .groupby(['Borough', 'Last outcome category'])
    .size()
    .reset_index(name='count')
)

top_locations = (
    df_borough
    .groupby('Borough')['count']
    .sum()
    .nlargest(n_locations)
    .index
    .tolist()
)
df_borough = df_borough[df_borough['Borough'].isin(top_locations)]

df_borough['rel_pct'] = (
    df_borough
    .groupby('Last outcome category')['count']
    .transform(lambda x: x / x.sum() * 100)
)

borough_order = top_locations
outcome_order   = df_borough['Last outcome category'].unique().tolist()

fig = px.density_heatmap(
    df_borough,
    x='Borough',
    y='Last outcome category',
    z='rel_pct',
    histfunc='sum',    # sums the one value per cell → rel_pct
    category_orders={
        'Borough': borough_order,
        'Last outcome category': outcome_order
    },
    color_continuous_scale=['green', 'yellow', 'red'],
    labels={'rel_pct': '% of Outcome'}
)

fig.update_layout(
    xaxis_title='Borough',
    yaxis_title='Outcome',
    title_x=0.5,
    title_y=0.95,
    title_font=dict(size=18),
)
fig.update_xaxes(tickangle=-45)
fig.update_yaxes(tickangle=-45)

fig.update_coloraxes(colorbar_tickformat=".1f")
fig.show()
```