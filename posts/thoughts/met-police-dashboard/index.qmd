---
title: London Crime Dashboard
description: a dashboard about London crime, as reported by the Metropolitan Police.
format: dashboard
theme: custom.scss
tags:
  - Thoughts
  - Publishing
  - Open Data
categories:
  - Thoughts
  - Open Data
  - London
date: 2025-04-19
---

## Introduction {.sidebar}
This dashboard draws on the Metropolitan Police’s [open London crime data](https://data.police.uk) and reflects only reported incidents - unreported crime isn’t included. All charts are interactive; just hover over them for extra detail.

```{python}
#| echo: false
#| output: false
# Recursively load all data under /home/pedro/datasets/met-police-data/, find files named *metropolitan-street.csv and add them to a single Pandas DataFrame
import os
import pandas as pd
import glob

files = glob.glob('/home/pedro/datasets/met-police-data/**/*metropolitan-street.csv', recursive=True)
print(f"Found {len(files)} files.")
dataframes = []
for file in files:
    df = pd.read_csv(file)
    dataframes.append(df)
# Concatenate all dataframes into a single dataframe
df = pd.concat(dataframes, ignore_index=True)
```

```{python}
#| echo: false
#| output: false
# Convert Month column to datetime
df['Month'] = pd.to_datetime(df['Month'], format='%Y-%m')
df['Year'] = df['Month'].dt.year
# Calculate earliest and latest date
earliest_date = df['Month'].min()
latest_date = df['Month'].max()
```

```{python}
#| echo: false
#| output: false
# Extract borough from 'LSOA name', matching 'borough xxxx'
df['Borough'] = df['LSOA name'].str.extract(r'(((\w|\s)+)\s(\d|\w)+$)', expand=False)[1]
```

```{python}
#| echo: false
#| output: false
df.head()
```

```{python}
#| echo: false
#| output: false
# Set a plotly template
import plotly.io as pio
pio.templates.default = "simple_white"
```

```{python}
#| echo: false
#| output: false
# Compute auxiliary data for the dashboard

# Unique outcomes
outcomes = df['Last outcome category'].unique()

# Unique crime types
crime_types = df['Crime type'].unique()

# Unique boroughs
boroughs = df['Borough'].unique()

# Total number of reported crimes
total_crimes_withID = df['Crime ID'].count()
total_crimes_withoutID = df['Crime ID'].isna().sum()
total_crimes = total_crimes_withID + total_crimes_withoutID

# Total crimes per month
total_crimes_per_month = df.groupby('Month')['Crime ID'].count().reset_index(name='count')

# Worst month for overall crime
worst_month = total_crimes_per_month.loc[total_crimes_per_month['count'].idxmax(), 'Month']
# Best month for overall crime
best_month = total_crimes_per_month.loc[total_crimes_per_month['count'].idxmin(), 'Month']

# Earliest date in the dataset
earliest_date_str = earliest_date.strftime('%Y-%m')
# Latest date in the dataset
latest_date_str = latest_date.strftime('%Y-%m')

# Total number of boroughs
total_boroughs = df['Borough'].nunique()

# Total crimes under investigation
total_crimes_under_investigation = df[df['Last outcome category'] == 'Under investigation']['Crime ID'].count()

# Total crimes by type
crime_type_counts = (
    df
    .groupby(['Crime type', 'Month'])
    .size()
    .reset_index(name='count')
)
crime_type_counts['delta'] = crime_type_counts.groupby('Crime type')['count'].diff()

# Worst month for each crime type
worst_months_crime_types = crime_type_counts.loc[crime_type_counts.groupby('Crime type')['count'].idxmax(), ['Crime type', 'Month']]
# Best month for each crime type
best_months_crime_types = crime_type_counts.loc[crime_type_counts.groupby('Crime type')['count'].idxmin(), ['Crime type', 'Month']]

# First vs latest three months
earliest_vs_latest_crime_counts = (
    crime_type_counts
    .groupby('Crime type')['count']
    .agg(
        first3=lambda x: x.iloc[:3].sum(),
        last3=lambda x: x.iloc[-3:].sum()
    )
    .assign(pct_delta=lambda df: ((df.last3 - df.first3) / df.first3 * 100).round(2))
    .reset_index()
).sort_values(
    'pct_delta',
    ascending=False
)

top_n_boroughs = 33

# Outcomes by borough
outcomes_by_borough = (
    df
    .groupby(['Borough', 'Last outcome category'])
    .size()
    .reset_index(name='count')
)

# Boroughs with the most reported crimes
top_boroughs = (
    outcomes_by_borough
    .groupby('Borough')['count']
    .sum()
    .nlargest(top_n_boroughs)
    .index
    .tolist()
)

total_outcomes_by_borough = outcomes_by_borough.groupby('Borough')['count'].transform('sum')

outcomes_by_borough['percentage'] = ((outcomes_by_borough['count'] / total_outcomes_by_borough) * 100).round(2)

# Crime types by Location
crime_types_by_location = (
    df[df['Location'] != 'On or near']
    .groupby(['Location', 'Crime type'])
    .size()
    .reset_index(name='count')
)

# Total number of reported crimes by location
total_crimes_by_location = crime_types_by_location.groupby('Location')['count'].transform('sum')

# Crime types by rounded lat/lon to three decimal places, where Latitude and Longitude are numbers
crime_types_by_coords = df[
    df['Latitude'].apply(lambda x: isinstance(x, (int, float))) &
    df['Longitude'].apply(lambda x: isinstance(x, (int, float)))
].copy()
crime_types_by_coords['Latitude'] = crime_types_by_coords['Latitude'].round(3)
crime_types_by_coords['Longitude'] = crime_types_by_coords['Longitude'].round(3)

```

```{python}
#| echo: false
#| output: false
# Compute an H3 grid for the crime types by location
import h3

valid = (
    df['Latitude'].between(-90, 90) &
    df['Longitude'].between(-180, 180)
)

valid_geo = df[valid]

h3_resolution = 9  # H3 resolution (0-15)

def safe_h3(lat, lon, res):
    try:
        return h3.latlng_to_cell(lat, lon, res)
    except h3.H3LatLngDomainError:
        return None

df['h3_index'] = [
    safe_h3(lat, lon, h3_resolution)
    for lat, lon in zip(df['Latitude'], df['Longitude'])
]

crimes_by_grid = (
    df
    .groupby(['h3_index', 'Crime type'])
    .size()
    .reset_index(name='count')
)
crimes_by_grid['total'] = crimes_by_grid.groupby('h3_index')['count'].transform('sum')
crimes_by_grid['percentage'] = ((crimes_by_grid['count'] / crimes_by_grid['total']) * 100).round(2)

# Grid with highest number of crimes
highest_crime_grid_h3 = crimes_by_grid.loc[crimes_by_grid['count'].idxmax(), 'h3_index']
```

# Summary

## Row
```{python}
#|content: valuebox
#|title: Earliest Date
dict(
    icon = "calendar",
    color = "info",
    value = earliest_date_str
)
```

```{python}
#|content: valuebox
#|title: Latest Date
dict(
    icon = "calendar",
    color = "info",
    value = latest_date_str
)
```

```{python}
#|content: valuebox
#|title: Identified Locations
dict(
    icon = "geo-alt-fill",
    color = "info",
    value = total_boroughs
)
```

## Row

```{python}
#|content: valuebox
#|title: Total Reported Crimes
dict(
    # icon = "arrow-left-square-fill",
    color = "danger",
    value = total_crimes
)
```

```{python}
#|content: valuebox
#|title: Total Reported Crimes with Crime Identifier
dict(
    icon = "person-check-fill",
    color = "light",
    value = total_crimes_withID
)
```

```{python}
#|content: valuebox
#|title: Total Reported Crimes without Crime Identifier
dict(
    icon = "person-dash-fill",
    color = "light",
    value = total_crimes_withoutID
)
```

# Outcomes

## Row

```{python}
#|content: valuebox
#|title: "% of crimes under investigation"
dict(
    icon = "person-check-fill",
    color = "light",
    value = f"{(total_crimes_under_investigation / total_crimes_withID) * 100:.2f}%"
)
```

```{python}
#|content: valuebox
#|title: "% of crimes with no further action"
# Percentage of crimes with no further action
no_further_action_outcomes = [
    'Further action is not in the public interest',
    'Further investigation is not in the public interest',
    'Formal action is not in the public interest',
    'Investigation complete; no suspect identified'
]
total_crimes_no_further_action = df[df['Last outcome category'].isin(no_further_action_outcomes)]['Crime ID'].count()
dict(
    icon = "person-dash-fill",
    color = "danger",
    value = f"{(total_crimes_no_further_action / total_crimes_withID) * 100:.2f}%"
)
```

```{python}
#|content: valuebox
#|title: "% of crimes without suspect identified"
# Percentage of crimes without suspect identified
no_suspect_outcomes = [
    'Investigation complete; no suspect identified'
]
total_crimes_no_suspect = df[df['Last outcome category'].isin(no_suspect_outcomes)]['Crime ID'].count()
dict(
    icon = "person-dash-fill",
    color = "danger",
    value = f"{(total_crimes_no_suspect / total_crimes_withID) * 100:.2f}%"
)
```

## Row

```{python}
#|title: Outcomes by Location (Top)
#|expandable: true
# Plot the distribution of outcomes by borough
import plotly.express as px

filtered = outcomes_by_borough[outcomes_by_borough['Borough'].isin(top_boroughs)]

fig = px.bar(
    filtered,
    x='count',
    y='Borough',
    color='Last outcome category',
    orientation='h',
    category_orders={'Borough': top_boroughs[::-1]},  # reverse so largest on top
    labels={'count': 'Outcomes', 'Borough': ''},
).update_layout(
    barmode='stack',
    margin=dict(l=20, r=20, t=20, b=20)
).update_coloraxes(showscale=False).update_traces(showlegend=False)

fig
```

```{python}
#|title: Outcomes by Location (Top) - as a % of Total
#|expandable: true
# Plot the distribution of outcomes by borough

fig = px.bar(
    filtered,
    x='percentage',
    y='Borough',
    color='Last outcome category',
    orientation='h',
    category_orders={'Borough': top_boroughs[::-1]},  # reverse so largest on top
    labels={'percentage': 'Percentage of Outcomes', 'Borough': ''},
    text='percentage'
).update_layout(
    barmode='stack',
    margin=dict(l=20, r=20, t=20, b=20)
).update_coloraxes(showscale=False).update_traces(showlegend=False)

fig
```

```{python}
#|title: Outcomes by Location
#|expandable: true
import geopandas as gpd
import folium
import branca
from folium import LayerControl

pivot = (
    filtered
    .pivot(index='Borough',
           columns='Last outcome category',
           values='percentage')
    .fillna(0)
)

london_boroughs = (
    gpd.read_file("london_boroughs.geojson")
       .set_crs(epsg=4326, allow_override=True)
       .rename(columns={"name":"Borough"})
)
merged = london_boroughs.merge(
    pivot.reset_index(),
    on="Borough",
    how="left"
).fillna(0)

m = folium.Map(
    location=[51.5074, -0.1278],
    zoom_start=10
)

_ = folium.TileLayer(
    tiles="CartoDB Positron",
    name="Map",
    control=False,
).add_to(m)

vmin, vmax = 0, pivot.values.max()
cmap = branca.colormap.linear.YlOrRd_09.scale(vmin, vmax)
cmap.caption = "% of outcomes in Borough"
_ = cmap.add_to(m)

for i, outcome in enumerate(pivot.columns):
    _ = folium.GeoJson(
        merged,
        name=outcome,
        overlay=False,
        control=True,
        style_function=lambda feat, o=outcome: {
            "fillColor": cmap(feat["properties"].get(o, 0)),
            "color": "black",
            "weight": 0.5,
            "fillOpacity": 0.7,
        },
        highlight_function=lambda feat: {
            "weight": 2,
            "color": "blue",
        },
        tooltip=folium.GeoJsonTooltip(
            fields=["Borough", outcome],
            aliases=["Borough", f"% {outcome}"],
            localize=True,
            sticky=False
        ),
        show=(i == 6) # Show the nth layer (outcome) by default
    ).add_to(m)

_ = LayerControl(position='topright', collapsed=False).add_to(m)

m
```

# Trends

## Row

```{python}
#|content: valuebox
#|title: Variation in all crime (earliest 3 months vs latest 3 months)"
total_crimes_earliest = earliest_vs_latest_crime_counts['first3'].sum()
total_crimes_latest = earliest_vs_latest_crime_counts['last3'].sum()
value = ((total_crimes_latest - total_crimes_earliest) / total_crimes_earliest) * 100
if value > 0:
    color = "danger"
    icon = "arrow-up-right-square-fill"
else:
    color = "success"
    icon = "arrow-down-right-square-fill"
dict(
    icon = icon,
    color = color,
    value = f"{value:.2f}%"
)
```

```{python}
#|content: valuebox
#|title: Largest increase
highest_increase_crime_type, highest_increase_crime_type_pct = \
    earliest_vs_latest_crime_counts.loc[
        earliest_vs_latest_crime_counts['pct_delta'].idxmax(), 
        ['Crime type','pct_delta']
    ].values
dict(
    icon = "arrow-up-right-square-fill",
    color = "danger",
    value = f"{highest_increase_crime_type} ({highest_increase_crime_type_pct:.2f}%)"
)
```

```{python}
#|content: valuebox
#|title: Largest decrease
highest_decrease_crime_type, highest_decrease_crime_type_pct = \
    earliest_vs_latest_crime_counts.loc[
        earliest_vs_latest_crime_counts['pct_delta'].idxmin(), 
        ['Crime type','pct_delta']
    ].values
dict(
    icon = "arrow-down-right-square-fill",
    color = "success",
    value = f"{highest_decrease_crime_type} ({highest_decrease_crime_type_pct:.2f}%)"
)
```

## Row {height=40%}

```{python}
#|title: Overall crime trend
#|expandable: true

fig = px.line(
    total_crimes_per_month,
    x='Month',
    y='count',
    labels={'count': 'Crimes', 'Month': 'Month'},
).update_layout(
    xaxis_tickformat='%Y-%m',
    xaxis_tickangle=-45,
    margin=dict(l=20, r=20, t=20, b=20),
    showlegend=False
).add_annotation(
    x=worst_month,
    y=total_crimes_per_month.loc[total_crimes_per_month['Month'] == worst_month, 'count'].values[0],
    text="Worst month",
    showarrow=True,
    arrowhead=2,
    ax=0,
    ay=-40,
    font=dict(color="red")
).add_annotation(
    x=best_month,
    y=total_crimes_per_month.loc[total_crimes_per_month['Month'] == best_month, 'count'].values[0],
    text="Best month",
    showarrow=True,
    arrowhead=2,
    ax=0,
    ay=-40,
    font=dict(color="green")
)
fig
```

```{python}
#|content: valuebox
#|title: Worst month for overall crime
dict(
    icon = "arrow-up-right-square-fill",
    color = "danger",
    value = worst_month.strftime('%Y-%m')
)
```

```{python}
#|content: valuebox
#|title: Best month for overall crime
dict(
    icon = "arrow-down-right-square-fill",
    color = "success",
    value = best_month.strftime('%Y-%m')
)
```

## Row

```{python}
#|title: Crime variation (first reported 3 months vs last reported 3 months)
#|expandable: true

fig = px.bar(
    earliest_vs_latest_crime_counts,
    x='pct_delta',
    y='Crime type',
    color='pct_delta',
    color_continuous_scale=['green', 'yellow', 'red'],  # Green (smallest) to Red (largest)
    orientation='h',
    labels={'pct_delta': 'Percentage Change', 'Crime type': ''},
).update_layout(
    margin=dict(l=20, r=20, t=20, b=20),
    showlegend=False  # Added to hide the legend
).update_coloraxes(
    showscale=False
)

fig
```

```{python}
#|title: Monthly Crimes
#|expandable: true

fig = px.bar(
    crime_type_counts,
    x='Month',
    y='count',
    color='Crime type',
    barmode='stack',
    labels={
        'count': 'Crimes',
        'Month': 'Month'
    },
)

fig.update_layout(
    xaxis_tickformat='%Y-%m',
    xaxis_tickangle=-45,
    margin=dict(l=20, r=20, t=20, b=20),
    showlegend=False
)
```

```{python}
#|title: Monthly Crime - Month on Month Change
#|expandable: true

delta = crime_type_counts.dropna(
    subset=['delta']
).copy()

fig = px.bar(
    delta,
    x='Month',
    y='delta',
    color='Crime type',
    barmode='relative',   # shows positives above, negatives below
    labels={'delta':'Δ Crimes','Month':'Month'},
).update_layout(
    xaxis_tickformat='%Y‑%m',
    xaxis_tickangle=-45,
    margin=dict(l=20, r=20, t=50, b=20),
    showlegend=False
)

fig
```

# Locations

## Row {height=30%}

```{python}
#|content: valuebox
#|title: Total geo-grids
dict(
    icon = "geo-alt-fill",
    color = "info",
    value = df['h3_index'].nunique()
)
```

```{python}
#|content: valuebox
#|title: Total geo-located crimes
dict(
    icon = "geo-alt-fill",
    color = "info",
    value = df['h3_index'].count()
)
```

```{python}
#|title: Grid with highest number of crimes
#|expandable: true
import folium
import h3

# Create a Folium map centered on the highest crime grid
boundary = h3.cell_to_boundary(highest_crime_grid_h3)
total_crimes_in_grid = crimes_by_grid.loc[crimes_by_grid['h3_index'] == highest_crime_grid_h3, 'count'].values[0]
m = folium.Map(location=boundary[0], zoom_start=15, tiles="CartoDB Positron")
# Highlight the boundary
_ = folium.Polygon(
    locations=boundary,
    color='red',
    fill=True,
    fill_opacity=0.4,
    tooltip=f"Total crimes: {total_crimes_in_grid}"
).add_to(m)

m
```

## Row

```{python}
#|title: All crime heatmap
#|expandable: true
import folium
from folium.plugins import HeatMap
import h3
import numpy as np

centroids = [h3.cell_to_latlng(idx) for idx in crimes_by_grid['h3_index']]
lats, lons = zip(*centroids)
lat_center, lon_center = np.mean(lats), np.mean(lons)

m = folium.Map(
    location=[lat_center, lon_center],
    zoom_start=12,
    tiles="CartoDB Positron"
)

heat_data = [
    [lat, lon, np.log1p(cnt)]
    for (lat, lon), cnt in zip(centroids, crimes_by_grid['count'])
]

weights = [w for _, _, w in heat_data]
cap = np.percentile(weights, 95)

_ = HeatMap(
    heat_data,
    radius=20,       # size of each hotspot
    blur=15,         # smoothing
    max_zoom=12,     # zoom where points hit max intensity
    min_opacity=0.2, # faintest opacity
    max_val=cap      # clamp top 5%
).add_to(m)

m
```

```{python}
#|title: All crime hotspots (top 1 percentile)
#|expandable: true
import folium
import h3
import numpy as np

count_thresh = np.percentile(crimes_by_grid['count'], 99)
hotspots = crimes_by_grid[crimes_by_grid['count'] >= count_thresh]

centroids = [h3.cell_to_latlng(idx) for idx in hotspots['h3_index']]
lats, lons = zip(*centroids)
lat_center, lon_center = np.mean(lats), np.mean(lons)

m = folium.Map(
    location=[lat_center, lon_center],
    zoom_start=12,
    tiles="CartoDB Positron"
)

scale_factor = 25  # metres per log-crime unit
for idx, cnt in zip(hotspots['h3_index'], hotspots['count']):
    lat, lon = h3.cell_to_latlng(idx)
    radius = scale_factor * np.log1p(cnt)
    _ = folium.Circle(
        location=[lat, lon],
        radius=radius,
        color='crimson',
        weight=1,
        fill=True,
        fill_opacity=0.2,
        tooltip=f"Crime count: {cnt}"
    ).add_to(m)

m
```


