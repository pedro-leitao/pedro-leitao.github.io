{
  "hash": "6dadcae10e409fa4f9d630e6dccd4319",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Flow Control\nsubtitle: conditional statements, loops, and functions\njupyter: python3\nformat:\n  html:\n    code-fold: false\n---\n\n\n\nAny language has a way to control the flow of the program. This is primarily done by using conditional statements, loops, and functions. Flow control is the order in which the program executes statements - think of it like being directed by a traffic policeman on a busy road. The traffic policeman directs the traffic to move in a certain direction, stop, or go back. Similarly, flow control in programming directs the program to execute certain statements based on conditions, loop through a set of statements, or call a function.\n\n\n## Basic flow control\n\nLet us start with the basic flow control statements in Python. Say that you want a program to execute a certain block of code only if a certain condition is met. This is where the `if` statement comes into play. The `if` statement is used to check a condition and execute a block of code only if the condition is `True`.\n\n::: {#8ffbcd4c .cell execution_count=1}\n``` {.python .cell-code}\nnumber = 4\n\nif number % 2 == 0:\n    print(\"Number is even\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber is even\n```\n:::\n:::\n\n\nThis example takes a number, and if it is divisible by two (the `%` operator is the modulo operator, which gives the remainder of the division of two numbers), it prints \"Number is even\". What follows the `if` statement is called the \"condition\", and it is a boolean expression that evaluates to either `True` or `False`. In fact you can print the evaluation of the condition alone to understand how this works:\n\n::: {#4565558b .cell execution_count=2}\n``` {.python .cell-code}\nprint(number % 2 == 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nBut what if the number is not divisible by two? In that case, you can use the `else` statement to execute a block of code when the `if` condition is `False`.\n\n::: {#1f7bdb19 .cell execution_count=3}\n``` {.python .cell-code}\nnumber = 5\n\nif number % 2 == 0:\n    print(\"Number is even\")\nelse:\n    print(\"Number is odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber is odd\n```\n:::\n:::\n\n\nThe above is called an `if-else` statement. If the condition in the `if` statement is `True`, the block of code under the `if` statement is executed. If the condition is `False`, the block of code under the `else` statement is executed. This is also an `if-else` statement, but with multiple conditions. If the condition in the `if` statement is `True`, the block of code under the `if` statement is executed. If the condition in the `elif` statement is `True`, the block of code under the `elif` statement is executed. If none of the conditions are `True`, the block of code under the `else` statement is executed.\n\nLet us look at such an example:\n\n::: {#b964e468 .cell execution_count=4}\n``` {.python .cell-code}\nnumber = 5\n\nif number > 0:\n    print(\"Number is positive\")\nelif number < 0:\n    print(\"Number is negative\")\nelse:\n    print(\"Number is zero\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber is positive\n```\n:::\n:::\n\n\nHere we check for two conditions, if the number if larger than zero, smaller than zero **or** neither (the final `else` statement). The `elif` statement is short for \"else if\", and is used to check multiple conditions. You can have as many `elif` statements as you want, but only one `if` and one `else` statement.\n\n## Loops\n\nLoops are used to execute a block of code multiple times. There are two types of loops in Python: `for` loops and `while` loops. A `for` loop is used to iterate over a sequence (like a list, tuple, or string) and execute a block of code for each element in the sequence. A `while` loop is used to execute a block of code as long as a condition is `True`.\n\n### For loops\n\nIn the previous section we looked at complex data types like lists and tuples. Let us use them in a `for` loop to take a list of numbers, and create a new list with each number squared.\n\n::: {#6f95a104 .cell execution_count=5}\n``` {.python .cell-code}\nnumbers = [1, 2, 3, 4, 5]\n\nsquared_numbers = []\nfor number in numbers:\n    squared_numbers.append(number ** 2) # ** is the power operator\n\nprint(squared_numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 4, 9, 16, 25]\n```\n:::\n:::\n\n\nThe for loop iterates over the list `numbers`, and for each number in the list, it appends the square of the number to the list `squared_numbers`. `for` loops work equally well with other sequences. Let us look at an example with a dictionary. We will take a dictionary with several people, and will calculate the average age in the group.\n\n::: {#5f6b7980 .cell execution_count=6}\n``` {.python .cell-code}\npersons = {\n    \"Alice\": 21,\n    \"Bob\": 27,\n    \"Charlie\": 37\n}\n\nsum = 0\nfor person in persons:\n    sum = sum + persons[person]\n\naverage_age = sum // len(persons)\n\nprint(average_age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n28\n```\n:::\n:::\n\n\nThe above code iterates through everyone in the `persons` dictionary, and sums everyone ages. Once the for loop is complete, it then calculates the average age by dividing the `sum` by the number of people in the list.\n\n```{.callout-note}\n## About the `len` Function\n\nThe `len` function takes a sequence (a list, tuple or dictionary) as an argument, and returns the number of elements in the sequence.\n```\n\n### for loops with range\n\nThe `range` function is used to generate a sequence of numbers. It takes three arguments: `start`, `stop`, and `step`. The `start` argument is the first number in the sequence, the `stop` argument is the number that the sequence stops before, and the `step` argument is the difference between each number in the sequence.\n\nIt is often used in `for` loops to iterate a certain number of times. Let us look at an example where we construct a long list of numbers based on `for` and `range`.\n\n::: {#4a02efe9 .cell execution_count=7}\n``` {.python .cell-code}\nnumbers = []\nfor i in range(1, 20, 1): # range(start, stop, step)\n    numbers.append(i)\n\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n```\n:::\n:::\n\n\n### The while loop\n\nBesides the for loop, Python also has a `while` loop. `while` is used to execute a block of code as long as a condition is `True`. It is normally used when you do not know how many times you need to execute a block of code, and you only want to stop when a certain condition is met.\n\nThe simplest while loop is one that runs forever. This is done by using the `True` boolean value as the condition. This is useful when you want to run a program that listens for user input, or a program that runs continuously in the background.\n\n```{.callout-note}\n## Stopping a Program\n\nTo stop a program that runs forever, you can use the `Ctrl+C` keyboard shortcut. In Jupyter notebooks, you can stop the execution of a cell by clicking the stop button in the toolbar.\n```\n\n::: {#d9f6cecd .cell execution_count=8}\n``` {.python .cell-code}\nwhile True:\n    print(\"This will run forever\")\n    break # This will artificially break out of the loop\n\nwhile False:\n    print(\"This will never run\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis will run forever\n```\n:::\n:::\n\n\nAs a more interesting example, let us calculate how many times we would need to fold a piece of paper to reach the moon. The thickness of a piece of paper is 0.1 mm, and the distance to the moon is 384,400 km. We will fold the paper in half each time.\n\n::: {#f951644d .cell execution_count=9}\n``` {.python .cell-code}\nmoon_distance = 384000 * 1000 * 1000 # millimeters\npaper_thickness = 0.1 # millimeters\nfolded_thickness = paper_thickness\n\nfolds = 0\nwhile folded_thickness < moon_distance:\n    folded_thickness *= 2 # This is the same as folded_thickness = folded_thickness * 2\n    folds += 1\n\nprint(folds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42\n```\n:::\n:::\n\n\nA `while` loop can also be used in the context of sequences. For example, we can use a `while` loop to reverse the order of a list of numbers by using the `pop` method of a list.\n\n```{.callout-note}\n## About the `pop` Method\n\nThe `pop` method of a list removes the last element of the list and returns it. If you do not provide an index to the `pop` method, it will remove the last element of the list.\n```\n\n::: {#21f88efa .cell execution_count=10}\n``` {.python .cell-code}\nnumbers = [1, 2, 3, 4, 5]\ninverse_numbers = []\n\nwhile numbers:\n    inverse_numbers.append( numbers.pop() )\n\nprint(inverse_numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5, 4, 3, 2, 1]\n```\n:::\n:::\n\n\n## break and continue\n\nSometimes you want to stop a loop before it has finished, or skip the rest of the code in a loop and continue with the next iteration. This is done using the `break` and `continue` statements. The `break` statement is used to exit a loop, and the `continue` statement is used to skip the rest of the code in a loop and continue with the next iteration.\n\nLet us look at an example of a `for` loop that iterates over a list of numbers, and stops when it reaches a number that is divisible by 3.\n\n::: {#2f07fca7 .cell execution_count=11}\n``` {.python .cell-code}\nnumbers = [10, 17, 21, 31, 56]\n\nfor number in numbers:\n    if number % 3 == 0:\n        print(number)\n        break\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n21\n```\n:::\n:::\n\n\nRemember the `else` in the `if-else` statement? It can also be used in a loop. The `else` statement in a loop is executed when the loop has finished iterating over the entire sequence. It is not executed if the loop is exited using a `break` statement. Let us put that to good use from the previous example.\n\n::: {#e5b652df .cell execution_count=12}\n``` {.python .cell-code}\nnumbers = [10, 17, 22, 31, 56]\n\nfor number in numbers:\n    if number % 3 == 0:\n        print(number)\n        break # This will break out of the for loop\nelse:\n    print(\"No number was divisible by 3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNo number was divisible by 3\n```\n:::\n:::\n\n\nThe `continue` statement is used to skip the rest of the code in a loop and continue with the next iteration. This is useful when, for example, you want to skip certain elements in a sequence. Let us look at an example where we take a list, and build another list without any numbers which are divisible by 3.\n\n::: {#9cd3ba00 .cell execution_count=13}\n``` {.python .cell-code}\nnumbers = [10, 17, 21, 31, 56]\n\nwithout_divisible_by_3 = []\nfor number in numbers:\n    if number % 3 == 0:\n        continue\n    without_divisible_by_3.append(number)\n\nprint(without_divisible_by_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10, 17, 31, 56]\n```\n:::\n:::\n\n\n## match\n\nThe `match` statement is used to compare a value against a set of patterns, and execute a block of code based on the pattern that matches. It is similar to a series of `if-elif-else` statements, but is more concise and easier to read. Here is a practical example of a `match` statement that takes a number, and prints a string based on the number.\n\n::: {#00ed521e .cell execution_count=14}\n``` {.python .cell-code}\nnumber = 1\n\nmatch number:\n    case 0:\n        print(\"Zero\")\n    case 1:\n        print(\"One\")\n    case 2:\n        print(\"Two\")\n    case 3:\n        print(\"Three\")\n    case _:\n        print(\"Something else\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOne\n```\n:::\n:::\n\n\n## Exercises\n\n1. Write a program that takes a sequence of numbers, and prints only positive numbers in the sequence.\n2. Write a program which computes the factorial of a number.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}