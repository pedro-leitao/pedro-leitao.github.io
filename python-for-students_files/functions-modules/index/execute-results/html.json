{
  "hash": "2ba918e0fbbf12b47f8bc65df1875cce",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Functions and Modules\nsubtitle: how to use functions and modules in Python\njupyter: python3\nformat:\n  html:\n    code-fold: false\n---\n\n\n\nIn math you will have likely seen functions like $f(x) = x^2$ or $g(x) = \\sin(x)$. In programming, functions are similar. They are a \"black box\" that takes in some input and returns some output.\n\nIn Python, functions come in multiple flavors - built-in functions, functions from modules, and user-defined functions. Built-in functions are available in Python without needing to import anything. Functions from modules are functions that are part of a module, and you need to import the module to use them. User-defined functions are functions that you define yourself.\n\nAn example of a built-in function which you have already seen is `print()`. An example of a function from a module is `math.sqrt()`. In previous sections you have also seen how you can define your own funtion, for example a function to calculate the acummulated value of an investment with a starting principal, an interest rate and a number of years.\n\n::: {#665f00ff .cell execution_count=1}\n``` {.python .cell-code}\ndef compound(rate, years, principal):\n    return principal * (1 + rate) ** years\n\n# Compound interest at 5% for 5 years on $1000\nprint(\n    compound(0.05, 5, 1000)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1276.2815625000003\n```\n:::\n:::\n\n\n## Packages and modules\n\nPython has thousands of third-party packages that you can use to extend the functionality of the language. These cover a wide range of topics, from data analysis to web development. Pretty much if you can think of it, there is probably a package that covers it!\n\nYou have already installed Anaconda, and you can use the `conda` package manager to see what packages are installed on your system.\n\n```bash\nconda list\n```\n\nWhich will show you a list of all the packages installed in your current environment. This will likely be a long list, so don't feel like you need to read through it all! Running the above command will show you something like this:\n\n```\n# packages in environment at /Volumes/Home/pedroleitao/miniconda3:\n#\n# Name                    Version                   Build  Channel\nanaconda-anon-usage       0.4.4           py312hd6b623d_100  \nanaconda-client           1.12.3          py312hca03da5_0  \nanaconda-cloud-auth       0.5.1           py312hca03da5_0  \nanaconda-navigator        2.6.0           py312hca03da5_0  \nannotated-types           0.6.0           py312hca03da5_0  \narchspec                  0.2.3              pyhd3eb1b0_0  \nattrs                     23.1.0          py312hca03da5_0  \nboltons                   23.0.0          py312hca03da5_0  \nbrotli-python             1.0.9           py312h313beb8_8  \nbzip2                     1.0.8                h80987f9_6  \nc-ares                    1.19.1               h80987f9_0  \nca-certificates           2024.3.11            hca03da5_0  \ncertifi                   2024.2.2        py312hca03da5_0  \ncffi                      1.16.0          py312h80987f9_1  \nchardet                   4.0.0           py312hca03da5_1003\n...\n```\n\nSome of the most important packages that you will use include `numpy` (for numerical computing), `pandas` (for data manipulation), `matplotlib` (for plotting), and `scipy` (for scientific computing). You can install these packages using `conda install` (but you very likely don't need to as Anaconda should have included them).\n\n```bash\nconda install numpy pandas matplotlib scipy\n```\n\nYou can search and find packages on the [Anaconda website](https://anaconda.org/anaconda/repo) or on the [Python Package Index (PyPI)](https://pypi.org/).\n\n### A practical example\n\nLet us install a package from scratch, and use it in a program. To make things a bit visual, we will use the [ASE](https://ase-workshop-2023.github.io/tutorial/) package to generate visualise a molecular structure. First, we need to install the package. It is available in Conda Forge, so we can use the `conda install` command to add the package to our environment.\n\n```bash\nconda install ase\n```\n\nOnce it installs successfully, we can use it in a program. Here is an example program that visualises a molecule - you can rotate and zoom in with your mouse.\n\n::: {#84d19c1f .cell execution_count=2}\n``` {.python .cell-code}\nfrom ase.build import molecule\nfrom ase.visualize import view\n\nstructure = \"CH3CH2OCH3\"\n\natoms = molecule(structure)\n\nview(atoms, viewer='x3d')\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<html>\n    <head>\n        <title>ASE atomic visualization</title>\n        <link rel=\"stylesheet\" type=\"text/css\"             href=\"https://www.x3dom.org/release/x3dom.css\"></link>\n        <script type=\"text/javascript\"             src=\"https://www.x3dom.org/release/x3dom.js\"></script>\n    </head>\n    <body>\n        <X3D width=\"400px\"; height=\"300px\";>\n\n<!--Inserting Generated X3D Scene-->\n<scene>\n  <viewpoint position=\"0 0 9.130816\">\n    <group/>\n  </viewpoint>\n  <transform translation=\"-0.0 -0.0 -0.0\">\n    <group>\n      <group>\n        <transform translation=\"0 0 0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"0 0 0\"/>\n            </appearance>\n            <lineset vertexCount=\"5\">\n              <coordinate point=\"0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 0 0\"/>\n            </lineset>\n          </shape>\n        </transform>\n        <transform translation=\"0.0 0.0 0.0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"0 0 0\"/>\n            </appearance>\n            <lineset vertexCount=\"5\">\n              <coordinate point=\"0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 0 0\"/>\n            </lineset>\n          </shape>\n        </transform>\n        <transform translation=\"0 0 0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"0 0 0\"/>\n            </appearance>\n            <lineset vertexCount=\"5\">\n              <coordinate point=\"0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 0 0\"/>\n            </lineset>\n          </shape>\n        </transform>\n        <transform translation=\"0.0 0.0 0.0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"0 0 0\"/>\n            </appearance>\n            <lineset vertexCount=\"5\">\n              <coordinate point=\"0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 0 0\"/>\n            </lineset>\n          </shape>\n        </transform>\n      </group>\n      <group>\n        <transform translation=\"0.006429 -0.712741 0.0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"1.0 0.051 0.051\"/>\n            </appearance>\n            <sphere radius=\"0.66\"/>\n          </shape>\n        </transform>\n        <transform translation=\"0.0 0.705845 0.0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"0.565 0.565 0.565\"/>\n            </appearance>\n            <sphere radius=\"0.76\"/>\n          </shape>\n        </transform>\n        <transform translation=\"1.324518 -1.226029 0.0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"0.565 0.565 0.565\"/>\n            </appearance>\n            <sphere radius=\"0.76\"/>\n          </shape>\n        </transform>\n        <transform translation=\"-1.442169 1.160325 0.0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"0.565 0.565 0.565\"/>\n            </appearance>\n            <sphere radius=\"0.76\"/>\n          </shape>\n        </transform>\n        <transform translation=\"0.530962 1.086484 0.886881\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"1.0 1.0 1.0\"/>\n            </appearance>\n            <sphere radius=\"0.31\"/>\n          </shape>\n        </transform>\n        <transform translation=\"0.530962 1.086484 -0.886881\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"1.0 1.0 1.0\"/>\n            </appearance>\n            <sphere radius=\"0.31\"/>\n          </shape>\n        </transform>\n        <transform translation=\"1.241648 -2.313325 0.0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"1.0 1.0 1.0\"/>\n            </appearance>\n            <sphere radius=\"0.31\"/>\n          </shape>\n        </transform>\n        <transform translation=\"1.881329 -0.905925 -0.89171\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"1.0 1.0 1.0\"/>\n            </appearance>\n            <sphere radius=\"0.31\"/>\n          </shape>\n        </transform>\n        <transform translation=\"1.881329 -0.905925 0.89171\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"1.0 1.0 1.0\"/>\n            </appearance>\n            <sphere radius=\"0.31\"/>\n          </shape>\n        </transform>\n        <transform translation=\"-1.954863 0.780605 -0.885855\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"1.0 1.0 1.0\"/>\n            </appearance>\n            <sphere radius=\"0.31\"/>\n          </shape>\n        </transform>\n        <transform translation=\"-1.954863 0.780605 0.885855\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"1.0 1.0 1.0\"/>\n            </appearance>\n            <sphere radius=\"0.31\"/>\n          </shape>\n        </transform>\n        <transform translation=\"-1.502025 2.252083 0.0\">\n          <shape>\n            <appearance>\n              <material diffuseColor=\"1.0 1.0 1.0\"/>\n            </appearance>\n            <sphere radius=\"0.31\"/>\n          </shape>\n        </transform>\n      </group>\n    </group>\n  </transform>\n</scene>\n<!--End of Inserted Scene-->\n\n        </X3D>\n    </body>\n</html>\n\n```\n:::\n:::\n\n\nOver time you might end up installing a lot of packages, which you might or might not use or need anymore. You can remove packages using the `conda remove` command.\n\n```bash\nconda remove ase\n```\n\nThat will help you keep your environment clean and tidy.\n\n## Creating your own modules and functions\n\nYou have already seen how to create your own functions. You can also create your own modules. A module is a file that contains Python code. You can import the module into your program and use the functions and classes defined in the module. This is a great way to organise your code and make it more readable and manageable, so you don't end up having one huge file with all your code in it.\n\nTo create a module, you simply create a Python file with the `.py` extension. For example, say you are writing a program which needs some financial functions. Instead of including them in your main program, you can create a module called `finance.py` and put all your financial functions in there. You can then import the module into your main program and use the functions. For example:\n\n::: {#512f4f9b .cell execution_count=3}\n``` {.python .cell-code}\n%%writefile finance.py\n# A module for financial calculations\n\n# finance.py\n\ndef simple(rate, years, principal):\n    return principal * (1 + rate * years)\n\ndef compound(rate, years, principal):\n    return principal * (1 + rate) ** years\n\ndef amortize(rate, years, principal):\n    return principal * rate / (1 - (1 + rate) ** -years)\n\ndef present(value, rate, years):\n    return value / (1 + rate) ** years\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWriting finance.py\n```\n:::\n:::\n\n\nThe above would be saved in a file called `finance.py` (the `%%writefile` notation is for Jupyter Notebook, you would not include that in your `finance.py` file). You can then import the module into your main program and use the functions. For example:\n\n::: {#6c1b69e5 .cell execution_count=4}\n``` {.python .cell-code}\n# program.py\n\nfrom finance import compound\n\nprint(\"Interest on $1000 at 5% for 5 years:\")\nprint(\n    compound(0.05, 5, 1000)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInterest on $1000 at 5% for 5 years:\n1276.2815625000003\n```\n:::\n:::\n\n\nYou can create as many modules as you like, and you can also create packages, which are collections of modules. A package is simply a directory that contains a special file called `__init__.py` (which can be empty). You can then put your modules in the package directory and import them into your program. For example:\n\n```\nmy_package/\n    __init__.py\n    finance.py\n    physics.py\n```\n\nYou can then import the modules into your program like this:\n\n```\nimport my_package.finance\nimport my_package.physics\n```\n\nYour `__init__.py` file can also contain code that is run when the package is imported. This can be useful for setting up the package, for example by importing modules or setting up variables.\n\nPackages are however a bit more advanced, and you don't need to worry about them for now. Just remember that you can create your own modules and functions to help organise your code and make it more readable and manageable.\n\nAs a general rule, you should try to keep your functions short and simple. A good rule of thumb is that a function should do one thing and do it well. If a function is getting too long or complicated, you should consider breaking it up into smaller functions. This will make your code easier to read and maintain.\n\nYou should also organise modules so they contain related functions. For example, you might have a module called `math.py` which contains mathematical functions, and a module called `string.py` which contains string functions. This will make it easier to find the function you need when you are working on your program.\n\nFinally, you should give your functions and modules descriptive names. This will make it easier to understand what the function does, and will make your code more readable. For example, instead of calling a function `f()` you should call it something like `calculate_area_of_circle()`. This will make it clear what the function does, and will make your code easier to understand.\n\n## About functions\n\nPython is an extensive language, and there are a few things you should know about functions. This is not a deep dive into the Python language, and therefore we will not cover everything. However there are a few things that are important to know.\n\n### Arguments\n\nFunctions can take arguments, which are values that are passed to the function when it is called. For example, the `print()` function takes an argument, which is the value that is printed to the screen. Arguments can be of different types, such as integers, floats, strings, lists, dictionaries, and so on, and when defining the function you can specify the type of the arguments. Let us take the `compound` function from before, you can specify the type of the arguments like this:\n\n::: {#aec8d0de .cell execution_count=5}\n``` {.python .cell-code}\ndef compound(rate: float, years: int, principal: float):\n    return principal * (1 + rate) ** years\n```\n:::\n\n\nHere `rate: float` specifies that the `rate` argument should be a float. This makes the function definition explicit and easier to read as well. You can also specify default values for arguments, which means that if the argument is not provided when the function is called, the default value is used. For example:\n\n::: {#346feedf .cell execution_count=6}\n``` {.python .cell-code}\ndef compound(years: int, principal: float, rate: float = 0.05):\n    return principal * (1 + rate) ** years\n```\n:::\n\n\nIn the above we moved the order of the arguments because in Python you must specify the default arguments after the non-default arguments. You can also specify the arguments by name when calling the function, which can make the code more readable. For example:\n\n::: {#29919c07 .cell execution_count=7}\n``` {.python .cell-code}\nprint(\n    compound(years=5, principal=1000)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1276.2815625000003\n```\n:::\n:::\n\n\n### Return values\n\nFunctions can and typically do return a value. You can explicitly specify the type of the return value, which can make the function definition more readable.\n\n::: {#73d11297 .cell execution_count=8}\n``` {.python .cell-code}\ndef compound(principal: float, years: int, rate: float = 0.05) -> float:\n    return principal * (1 + rate) ** years\n```\n:::\n\n\n`-> float` explicitly specifies that the function should return a float. Note however that this notation does not *enforce* the return type, it is just a hint to the programmer.\n\nA function can also return multiple values, which are returned as a tuple. For example, let us change the `compound` function to return a tuple of floats with the accumulated value per year.\n\n::: {#4e283dfb .cell execution_count=9}\n``` {.python .cell-code}\ndef compound(principal: float, years: int, rate: float = 0.05) -> tuple[float]:\n    yearly_values = []\n\n    # For each year n, calculate the accumulated amount\n    for n in range(years + 1):\n        accumulated = principal * (1 + rate) ** n\n        yearly_values.append(accumulated)\n\n    # Convert the list to a tuple and return it\n    return tuple(yearly_values)\n\nprint(\n    compound(1000, 5)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1000.0, 1050.0, 1102.5, 1157.6250000000002, 1215.5062500000001, 1276.2815625000003)\n```\n:::\n:::\n\n\nIn the above we changed the return value to a tuple, and we added a loop to calculate the accumulated value per year. We then return the accumulated value as a tuple.\n\nThe function can be made shorter by using a list comprehension, which is a concise way to create lists (but not as readable as the loop).\n\n::: {#06a40295 .cell execution_count=10}\n``` {.python .cell-code}\ndef compound(principal: float, years: int, rate: float = 0.05) -> tuple[float]:\n    return tuple(\n        principal * (1 + rate) ** n\n        for n in range(years + 1)\n    )\n\nprint(\n    compound(1000, 5)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1000.0, 1050.0, 1102.5, 1157.6250000000002, 1215.5062500000001, 1276.2815625000003)\n```\n:::\n:::\n\n\n```{.callout-note}\n## About Generator Expressions\n\nThe comprehension above has two main parts: the expression `principal * (1 + rate) ** year` which calculates the accumulated value for each year, and the `for year in range(years)` which iterates over the years, put together as `(...) for n in range(...)` it is called a *generator expression*. The generator expression is then enclosed in the `tuple()` function which converts the result to a tuple. The comprehension could also be written as a single line: `tuple(principal * (1 + rate) ** year for year in range(years))`. But this would be less readable.\n```\n\nComprehensions are a powerful feature of Python, and you can use them to create lists, dictionaries, and sets. They are a concise way to create collections, and can make your code more readable and maintainable. We could change the function to use a list or dictionary comprehension as well!\n\n::: {#f70e7ba9 .cell execution_count=11}\n``` {.python .cell-code}\ndef compound(principal: float, years: int, rate: float = 0.05) -> list[float]:\n    return list(\n        principal * (1 + rate) ** n\n        for n in range(years + 1)\n    )\n\nprint(\n    compound(1000, 5)\n)\n\ndef compound(principal: float, years: int, rate: float = 0.05) -> dict[int, float]:\n    return {\n        n: principal * (1 + rate) ** n\n        for n in range(years + 1)\n    }\n\nprint(\n    compound(1000, 5)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1000.0, 1050.0, 1102.5, 1157.6250000000002, 1215.5062500000001, 1276.2815625000003]\n{0: 1000.0, 1: 1050.0, 2: 1102.5, 3: 1157.6250000000002, 4: 1215.5062500000001, 5: 1276.2815625000003}\n```\n:::\n:::\n\n\nNote how for the dictionary comprehension we define the return value as a dictionary with the year as the key and the accumulated value as the value. This makes the return value more explicit and easier to understand.\n\n```{.callout-note}\n## About Comprehensions\n\nComprehensions are a pretty advanced feature of Python. If you are just starting out with the language you might find them a bit confusing. Don't worry if you don't understand them right away - you can always come back to them later when you have practiced the basics some more. If on the other hand you understand the above code without much difficulty, you are doing great!\n```\n\n### Passing complex data types as arguments\n\nYou can pass complex data types as arguments to functions, such as lists, dictionaries, and objects. Let us change the `compound` function so it takes a an initial principal, and a list of rates for each year. This time let us not use a comprehension, as using a loop is easier to understand.\n\n::: {#6bfbe7b5 .cell execution_count=12}\n``` {.python .cell-code}\ndef compound(principal: float, rates: list[float]) -> list[float]:\n    \"\"\"\n    Calculate the accumulated capital after each year using\n    the corresponding rate for that year in 'rates'.\n    \"\"\"\n    accumulated_values = [principal]\n    accumulated = principal\n    \n    for rate in rates:\n        accumulated = accumulated * (1 + rate)\n        accumulated_values.append(accumulated)\n    \n    return accumulated_values\n    \nprint(\n    compound(\n        1000,\n        [0.05, 0.06, 0.07, 0.08, 0.09]\n    )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1000, 1050.0, 1113.0, 1190.91, 1286.1828000000003, 1401.9392520000004]\n```\n:::\n:::\n\n\nAs you can see the `rates` argument is a list of floats, and we loop over the list to calculate the accumulated value for each year. In turn the function then returns back a list of floats as before.\n\n## Recursion\n\nRecursion is one of those topics which result in a \"aha!\" moment when you understand it. It is a powerful concept, and can be used to solve problems that are difficult or impossible to solve with other techniques. Recursion is when a function calls itself. This might sound a bit strange at first, but it is a very powerful technique very much worth exploring and learning.\n\nA classic example of recursion is the factorial function. The factorial of a number is the product of all the positive integers up to that number. For example, the factorial of 5 is 5 * 4 * 3 * 2 * 1 = 120. The factorial function can be defined recursively as $n! = n \\times (n-1)!$ for n > 0. Or in Python:\n\n::: {#ee7d716a .cell execution_count=13}\n``` {.python .cell-code}\ndef factorial(n: int) -> int:\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n    \nprint(\n    factorial(5)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n120\n```\n:::\n:::\n\n\nThe above function *calls itself* with the argument `n-1`. This is the essence of recursion - a function that calls itself. The function will keep calling itself until it reaches the base case, which is when `n` is 0. At that point the function will return 1, and the recursion will stop. For example, if you call `factorial(5)` the function will call itself with `n=4`, then `n=3`, then `n=2`, then `n=1`, and finally `n=0`. At that point the function will return 1, and the recursion will stop.\n\nRecursion is used to solve problems of all kinds, from simple mathematical problems like the factorial function to complex problems like searching a tree or graph. It is a powerful technique, and once you understand it you will find many uses for it.\n\n```{.callout-note}\n## About Tower of Hanoi\n\nA really interesting recursion problem is the [Tower of Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi). It is a classic example that is often used to teach recursion. The problem is to move a stack of disks from one peg to another, using a third peg as a temporary storage. The rules are that you can only move one disk at a time, and you can never place a larger disk on top of a smaller disk. The problem can be solved recursively, and is a great way to learn about recursion.\n```\n\n![Tower of Hanoi](https://www.researchgate.net/publication/359575059/figure/fig2/AS:1139167622897665@1648610134121/The-initial-and-goal-states-of-Hanoi-Tower-game.png)\n\n## Chaining methods together\n\nIn Python you can chain methods together, which means that you can call one method on the result of another method. This can make your code more concise and readable, and can be a powerful way to work with objects. For example, say you have the text \"Hello, World!\" and you want to convert it to uppercase and then split it into words. You can do this with the `upper()` and `split()` methods in a chain like this:\n\n::: {#bb8578d6 .cell execution_count=14}\n``` {.python .cell-code}\ntext = \"Today is a beautiful day\"\ntext.upper().split()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n['TODAY', 'IS', 'A', 'BEAUTIFUL', 'DAY']\n```\n:::\n:::\n\n\nThe code works because a `string` object is returned by the `upper()` method, and a `list` object is returned by the `split()` method. You can chain as many methods together as you like, and you can also use indexing and slicing in the chain. For example, you can get the first word of the uppercase text like this:\n\n::: {#04175e8a .cell execution_count=15}\n``` {.python .cell-code}\ntext = \"Today is a beautiful day\"\ntext.upper().split()[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n'TODAY'\n```\n:::\n:::\n\n\nChaining methods together is very common and you will see it a lot in Python code. It is a powerful technique that can make your code more concise and readable, and can help you work with objects in a more natural way.\n\n## Exercises\n\n1. Write a simple program, which uses a module with your own functions to add, subtract and multiply numbers. The module should contain three functions, `add`, `subtract`, and `multiply`, which take two numbers as arguments and return the result of adding, subtracting, and multiplying the numbers, respectively. The program should import the module and use the functions to add, subtract, and multiply two numbers.\n2. Take the `compound` function, and change it so it uses a default principal of 10000 if none is provided.\n3. Write a function which calculates the Fibbonaci sequence using recursion.\n4. Write a function which solves the Towers of Hanoi problem using recursion (**this is a complex exercise**).\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}