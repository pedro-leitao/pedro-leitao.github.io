<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-02-09">

<title>How GPU’s work, an explainer using the Mandelbrot set – Pedro Leitão</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../_static/logo.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-a185852c63625fd9ffbdc57047c9a77e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-9143d267086697ee6a9fbeed7f968a66.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../_static/logo.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Bio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../posts.html"> 
<span class="menu-text">All posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../experiments.html"> 
<span class="menu-text">Experiments</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../thoughts.html"> 
<span class="menu-text">Thoughts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../howtos.html"> 
<span class="menu-text">Howto’s</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/pedro-leitao"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://linkedin.com/in/nunoleitao"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../../posts.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">How GPU’s work, an explainer using the Mandelbrot set</h1>
            <p class="subtitle lead">mandelbrot sets and parallelism</p>
                                <div class="quarto-categories">
                <div class="quarto-category">Experiments</div>
                <div class="quarto-category">GPU</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 9, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#a-quick-diversion-into-parallelism" id="toc-a-quick-diversion-into-parallelism" class="nav-link active" data-scroll-target="#a-quick-diversion-into-parallelism">A quick diversion into parallelism</a></li>
  <li><a href="#the-mandelbrot-set" id="toc-the-mandelbrot-set" class="nav-link" data-scroll-target="#the-mandelbrot-set">The Mandelbrot set</a></li>
  <li><a href="#calculating-the-mandelbrot-set-with-no-parallelism" id="toc-calculating-the-mandelbrot-set-with-no-parallelism" class="nav-link" data-scroll-target="#calculating-the-mandelbrot-set-with-no-parallelism">Calculating the Mandelbrot set with no parallelism</a></li>
  <li><a href="#calculating-the-mandelbrot-set-with-parallelism" id="toc-calculating-the-mandelbrot-set-with-parallelism" class="nav-link" data-scroll-target="#calculating-the-mandelbrot-set-with-parallelism">Calculating the Mandelbrot set with parallelism</a>
  <ul class="collapse">
  <li><a href="#numpy" id="toc-numpy" class="nav-link" data-scroll-target="#numpy">Numpy</a></li>
  <li><a href="#pytorch" id="toc-pytorch" class="nav-link" data-scroll-target="#pytorch">PyTorch</a></li>
  <li><a href="#apples-mlx" id="toc-apples-mlx" class="nav-link" data-scroll-target="#apples-mlx">Apple’s MLX</a></li>
  </ul></li>
  <li><a href="#putting-it-all-together" id="toc-putting-it-all-together" class="nav-link" data-scroll-target="#putting-it-all-together">Putting it all together</a></li>
  <li><a href="#plotting-the-set" id="toc-plotting-the-set" class="nav-link" data-scroll-target="#plotting-the-set">Plotting the set</a></li>
  <li><a href="#timing-the-functions" id="toc-timing-the-functions" class="nav-link" data-scroll-target="#timing-the-functions">Timing the functions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Every day pretty much all of us either uses or hears about the mythical GPU, the Graphics Processing Unit. It’s the thing that makes your games, video renders, and your machine learning models train faster. But how does it achieve that? What makes it different from a CPU?</p>
<p>We will do a quick explainer which should give you a good intuition using the <a href="https://www.quantamagazine.org/the-quest-to-decode-the-mandelbrot-set-maths-famed-fractal-20240126/">Mandelbrot set</a>. The Mandelbrot set is a fractal, a set of complex numbers that when iterated through a function, either diverges to infinity or stays bounded, it is the boundary between these two regions. The Mandelbrot set is a great example to use because it’s a simple function that can be parallelized easily.</p>
<section id="a-quick-diversion-into-parallelism" class="level2">
<h2 class="anchored" data-anchor-id="a-quick-diversion-into-parallelism">A quick diversion into parallelism</h2>
<p>During my university days I had a quick course on parallelism, where we were asked how we could parallelize the computation of the Mandelbrot set. The answer is simple, we can calculate each pixel independently, since at its core, calculating the set involves applying a function to each complex number to determine if it belongs to the set or not.</p>
<p>Back then the approach I followed was to divide the image into an <span class="math inline">\(n x n\)</span> grid and assign each grid to a separate networked computer, which would then calculate the pixels in that grid, and write results to a network shared file (this was back in the day where RPC was barely a thing). This is a simple form of parallelism, and it’s called <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrassingly parallel</a>.</p>
<p>Most GPU computations are embarrassingly parallel, and this is why they are so good at simple parallelism workloads. They have thousands of cores, and each core can act independently to compute a fragment of the workload.</p>
<p>They are adept at machine learning and AI workloads equally because most of the computations in these fields are matrix multiplications, which can be parallelized easily.</p>
</section>
<section id="the-mandelbrot-set" class="level2">
<h2 class="anchored" data-anchor-id="the-mandelbrot-set">The Mandelbrot set</h2>
<p>The Mandelbrot set is defined by the following function:</p>
<p><span class="math display">\[
f(z) = z^2 + c
\]</span></p>
<p>where <span class="math inline">\(z\)</span> is a complex number, and <span class="math inline">\(c\)</span> is a constant complex number. We can iterate this function, and if the magnitude of <span class="math inline">\(z\)</span> is greater than 2, then we can say that the function diverges to infinity. If it doesn’t, then it stays bounded. The Mandelbrot set is the boundary between these two regions.</p>
<p>Further below we will show a rendered image of the Mandelbrot set, but first, let’s write a simple Python function to calculate it.</p>
</section>
<section id="calculating-the-mandelbrot-set-with-no-parallelism" class="level2">
<h2 class="anchored" data-anchor-id="calculating-the-mandelbrot-set-with-no-parallelism">Calculating the Mandelbrot set with no parallelism</h2>
<p>Let’s start by writing a simple, naive function to calculate the Mandelbrot set. This function uses <em>no</em> parallelism, and it’s a simple for loop that iterates over each pixel in the image and calculates each using the CPU only. It basically iterates over columns and rows and computes whether that particular point diverges or not as nested loops.</p>
<p>For a width of 500 and height of 500, this function will compute <span class="math inline">\(250000\)</span> pixels, for a width of 1000 and height of 1000, it will compute <span class="math inline">\(1000000\)</span> pixels, and so on. The time taken for this function to run increase as <span class="math inline">\(O(n^2)\)</span> where <span class="math inline">\(n\)</span> is the width or height of the image.</p>
<div id="68e56eb5" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="68e56eb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="68e56eb5-1"><a href="#68e56eb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_mandelbrot_iterations(width, height, max_iter):</span>
<span id="68e56eb5-2"><a href="#68e56eb5-2" aria-hidden="true" tabindex="-1"></a>    real_min, real_max <span class="op">=</span> <span class="op">-</span><span class="dv">2</span>, <span class="dv">1</span></span>
<span id="68e56eb5-3"><a href="#68e56eb5-3" aria-hidden="true" tabindex="-1"></a>    imag_min, imag_max <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span></span>
<span id="68e56eb5-4"><a href="#68e56eb5-4" aria-hidden="true" tabindex="-1"></a>    real_step <span class="op">=</span> (real_max <span class="op">-</span> real_min) <span class="op">/</span> (width <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="68e56eb5-5"><a href="#68e56eb5-5" aria-hidden="true" tabindex="-1"></a>    imag_step <span class="op">=</span> (imag_max <span class="op">-</span> imag_min) <span class="op">/</span> (height <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="68e56eb5-6"><a href="#68e56eb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="68e56eb5-7"><a href="#68e56eb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize a 2D list to hold iteration counts.</span></span>
<span id="68e56eb5-8"><a href="#68e56eb5-8" aria-hidden="true" tabindex="-1"></a>    iter_counts <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(width)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(height)]</span>
<span id="68e56eb5-9"><a href="#68e56eb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="68e56eb5-10"><a href="#68e56eb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(height):</span>
<span id="68e56eb5-11"><a href="#68e56eb5-11" aria-hidden="true" tabindex="-1"></a>        imag <span class="op">=</span> imag_min <span class="op">+</span> j <span class="op">*</span> imag_step</span>
<span id="68e56eb5-12"><a href="#68e56eb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(width):</span>
<span id="68e56eb5-13"><a href="#68e56eb5-13" aria-hidden="true" tabindex="-1"></a>            real <span class="op">=</span> real_min <span class="op">+</span> i <span class="op">*</span> real_step</span>
<span id="68e56eb5-14"><a href="#68e56eb5-14" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> <span class="bu">complex</span>(real, imag)</span>
<span id="68e56eb5-15"><a href="#68e56eb5-15" aria-hidden="true" tabindex="-1"></a>            z <span class="op">=</span> <span class="ot">0j</span></span>
<span id="68e56eb5-16"><a href="#68e56eb5-16" aria-hidden="true" tabindex="-1"></a>            count <span class="op">=</span> <span class="dv">0</span></span>
<span id="68e56eb5-17"><a href="#68e56eb5-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> count <span class="op">&lt;</span> max_iter:</span>
<span id="68e56eb5-18"><a href="#68e56eb5-18" aria-hidden="true" tabindex="-1"></a>                z <span class="op">=</span> z <span class="op">*</span> z <span class="op">+</span> c</span>
<span id="68e56eb5-19"><a href="#68e56eb5-19" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Check divergence: if |z|^2 &gt; 4 then break.</span></span>
<span id="68e56eb5-20"><a href="#68e56eb5-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (z.real <span class="op">*</span> z.real <span class="op">+</span> z.imag <span class="op">*</span> z.imag) <span class="op">&gt;</span> <span class="dv">4</span>:</span>
<span id="68e56eb5-21"><a href="#68e56eb5-21" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="68e56eb5-22"><a href="#68e56eb5-22" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="68e56eb5-23"><a href="#68e56eb5-23" aria-hidden="true" tabindex="-1"></a>            iter_counts[j][i] <span class="op">=</span> count</span>
<span id="68e56eb5-24"><a href="#68e56eb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="68e56eb5-25"><a href="#68e56eb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> iter_counts</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="calculating-the-mandelbrot-set-with-parallelism" class="level2">
<h2 class="anchored" data-anchor-id="calculating-the-mandelbrot-set-with-parallelism">Calculating the Mandelbrot set with parallelism</h2>
<p>While the above function is simple, it is not the most efficient. Because it is basically a big matrix operation (an image <em>is</em> a matrix), we can parallelize it easily using a number of frameworks which offer matrix operations. Let’s investigate how we would do this using a number of libraries.</p>
<p>For this example, we will show how to achieve it using <code>numpy</code>, <code>pytorch</code> and Apple’s <code>mlx</code>. They all offer a similar API, and can be used virtually interchangeably. They offer a set of functionality which allows you to perform matrix operations on either the CPU and GPU:</p>
<ul>
<li>Vectorized Operations: They all let you perform elementwise operations on entire arrays/tensors without explicit loops, which boosts performance.</li>
<li>Broadcasting: NumPy, PyTorch, and MLX support broadcasting, allowing operations on arrays of different shapes — great for aligning matrices without manual reshaping.</li>
<li>Optimized Backends: Under the hood, they rely on highly optimized C/C++ libraries (like BLAS/LAPACK or Apple’s Accelerate framework for MLX) to perform computations quickly.</li>
<li>Multi-dimensional Data Handling: They all offer robust support for multi-dimensional arrays (or tensors), making them well-suited for tasks ranging from basic linear algebra to complex machine learning computations.</li>
</ul>
<section id="numpy" class="level3">
<h3 class="anchored" data-anchor-id="numpy">Numpy</h3>
<p>Let’s start with an implementation of the <code>compute_mandelbrot_iterations</code> function using <code>numpy</code>, entirely with array (or matrix) operations.</p>
<div id="4f011e40" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="4f011e40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="4f011e40-1"><a href="#4f011e40-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="4f011e40-2"><a href="#4f011e40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="4f011e40-3"><a href="#4f011e40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="4f011e40-4"><a href="#4f011e40-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_mandelbrot_numpy(</span>
<span id="4f011e40-5"><a href="#4f011e40-5" aria-hidden="true" tabindex="-1"></a>    width: <span class="bu">int</span> <span class="op">=</span> <span class="dv">500</span>, height: <span class="bu">int</span> <span class="op">=</span> <span class="dv">500</span>, max_iter: <span class="bu">int</span> <span class="op">=</span> <span class="dv">30</span></span>
<span id="4f011e40-6"><a href="#4f011e40-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="4f011e40-7"><a href="#4f011e40-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create linearly spaced real and imaginary parts and generate a complex grid.</span></span>
<span id="4f011e40-8"><a href="#4f011e40-8" aria-hidden="true" tabindex="-1"></a>    real <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">1</span>, width)</span>
<span id="4f011e40-9"><a href="#4f011e40-9" aria-hidden="true" tabindex="-1"></a>    imag <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>, height)</span>
<span id="4f011e40-10"><a href="#4f011e40-10" aria-hidden="true" tabindex="-1"></a>    X, Y <span class="op">=</span> np.meshgrid(real, imag, indexing<span class="op">=</span><span class="st">"xy"</span>)</span>
<span id="4f011e40-11"><a href="#4f011e40-11" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> X <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> Y</span>
<span id="4f011e40-12"><a href="#4f011e40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="4f011e40-13"><a href="#4f011e40-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize z and an array to hold the iteration counts</span></span>
<span id="4f011e40-14"><a href="#4f011e40-14" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> np.zeros_like(c)</span>
<span id="4f011e40-15"><a href="#4f011e40-15" aria-hidden="true" tabindex="-1"></a>    iter_counts <span class="op">=</span> np.zeros(c.shape, dtype<span class="op">=</span>np.int32)</span>
<span id="4f011e40-16"><a href="#4f011e40-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="4f011e40-17"><a href="#4f011e40-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="4f011e40-18"><a href="#4f011e40-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create a mask for points that have not yet diverged</span></span>
<span id="4f011e40-19"><a href="#4f011e40-19" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> np.<span class="bu">abs</span>(z) <span class="op">&lt;</span> <span class="dv">4</span></span>
<span id="4f011e40-20"><a href="#4f011e40-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> mask.<span class="bu">any</span>():</span>
<span id="4f011e40-21"><a href="#4f011e40-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="4f011e40-22"><a href="#4f011e40-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="4f011e40-23"><a href="#4f011e40-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update z and iteration counts only where |z| &lt; 4</span></span>
<span id="4f011e40-24"><a href="#4f011e40-24" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> np.where(mask, z <span class="op">*</span> z <span class="op">+</span> c, z)</span>
<span id="4f011e40-25"><a href="#4f011e40-25" aria-hidden="true" tabindex="-1"></a>        iter_counts <span class="op">=</span> np.where(mask, iter_counts <span class="op">+</span> <span class="dv">1</span>, iter_counts)</span>
<span id="4f011e40-26"><a href="#4f011e40-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="4f011e40-27"><a href="#4f011e40-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> iter_counts</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>This function starts by generating a grid of complex numbers using matrix operations, which is key for parallel computation. It first creates two linearly spaced arrays for the real and imaginary parts using <code>np.linspace</code>, and then builds two 2D grids with <code>np.meshgrid</code> — one for the real values and one for the imaginary values. These grids are combined into a single complex grid <code>c</code> (where each element is of the form <code>x + 1j * y</code>), and this process happens all at once without the need for explicit loops, leveraging NumPy’s vectorized operations.</p>
<p>Next, the code initializes two arrays of the same shape as <code>c</code>: one for the iterative values <code>z</code> (starting at zero) and one to keep track of the iteration counts. The main computation occurs in a loop where, in each iteration, the code computes the absolute value of every element in <code>z</code> simultaneously using <code>np.abs(z)</code> and creates a boolean mask that identifies the elements where <code>|z| &lt; 4</code>. This mask is then used to update <code>z</code> and <code>i</code>ter_counts<code>in one go via</code>np.where`, ensuring that only the elements that haven’t diverged (i.e., where the condition holds) are updated.</p>
<p>Because these operations — creating the grid, computing absolute values, applying the mask, and updating arrays — are all performed on entire arrays at once, they are handled in parallel by optimized C code under the hood. This eliminates the need for slow, explicit Python loops, which is why such an approach is highly efficient for intensive computations like generating the Mandelbrot set. The combination of vectorized operations and conditional updates not only makes the code concise but also allows the underlying hardware to execute many operations concurrently, resulting in much faster computation.</p>
</section>
<section id="pytorch" class="level3">
<h3 class="anchored" data-anchor-id="pytorch">PyTorch</h3>
<p>Now let us do the same but with the <code>pytorch</code> library, except for the line <code>c = X.t() + 1j * Y.t()</code>, the code is identical to the <code>numpy</code> implementation. The <code>t()</code> function is used to transpose the matrix, and the <code>+</code> and <code>*</code> operators are overloaded to perform elementwise addition and multiplication, respectively. This allows us to create the complex grid <code>c</code> in a single line, just like in the <code>numpy</code> version.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>The reason you see a transpose in PyTorch is because its grid creation defaults to a different dimension ordering than <code>numpy</code>’s. In <code>numpy</code>, when you use <code>np.meshgrid</code> with <code>indexing='xy'</code>, the resulting arrays have the first dimension corresponding to the y-axis and the second to the x-axis, matching common image coordinate conventions. <code>pytorch</code>’s <code>torch.meshgrid</code>, on the other hand, typically returns tensors where the dimensions are swapped relative to that layout. By transposing (<code>.t()</code>) the <code>pytorch</code> tensors, you align the dimensions so that the complex grid <code>c</code> ends up with the same arrangement as in <code>numpy</code>. This ensures that each element in <code>c</code> correctly corresponds to the intended coordinate in the complex plane.</p>
</div>
</div>
<div id="b8cd3dee" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="b8cd3dee"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="b8cd3dee-1"><a href="#b8cd3dee-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="b8cd3dee-2"><a href="#b8cd3dee-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="b8cd3dee-3"><a href="#b8cd3dee-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="b8cd3dee-4"><a href="#b8cd3dee-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_mandelbrot_torch(</span>
<span id="b8cd3dee-5"><a href="#b8cd3dee-5" aria-hidden="true" tabindex="-1"></a>    width: <span class="bu">int</span> <span class="op">=</span> <span class="dv">500</span>, height: <span class="bu">int</span> <span class="op">=</span> <span class="dv">500</span>, max_iter: <span class="bu">int</span> <span class="op">=</span> <span class="dv">30</span>, device: <span class="bu">str</span> <span class="op">=</span> <span class="st">"cpu"</span></span>
<span id="b8cd3dee-6"><a href="#b8cd3dee-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> torch.Tensor:</span>
<span id="b8cd3dee-7"><a href="#b8cd3dee-7" aria-hidden="true" tabindex="-1"></a>    real <span class="op">=</span> torch.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">1</span>, steps<span class="op">=</span>width, device<span class="op">=</span>device)</span>
<span id="b8cd3dee-8"><a href="#b8cd3dee-8" aria-hidden="true" tabindex="-1"></a>    imag <span class="op">=</span> torch.linspace(<span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>, steps<span class="op">=</span>height, device<span class="op">=</span>device)</span>
<span id="b8cd3dee-9"><a href="#b8cd3dee-9" aria-hidden="true" tabindex="-1"></a>    X, Y <span class="op">=</span> torch.meshgrid(real, imag, indexing<span class="op">=</span><span class="st">"xy"</span>)</span>
<span id="b8cd3dee-10"><a href="#b8cd3dee-10" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> X.t() <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> Y.t()</span>
<span id="b8cd3dee-11"><a href="#b8cd3dee-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="b8cd3dee-12"><a href="#b8cd3dee-12" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> torch.zeros_like(c)</span>
<span id="b8cd3dee-13"><a href="#b8cd3dee-13" aria-hidden="true" tabindex="-1"></a>    iter_counts <span class="op">=</span> torch.zeros(c.shape, device<span class="op">=</span>device, dtype<span class="op">=</span>torch.int32)</span>
<span id="b8cd3dee-14"><a href="#b8cd3dee-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="b8cd3dee-15"><a href="#b8cd3dee-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="b8cd3dee-16"><a href="#b8cd3dee-16" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> torch.<span class="bu">abs</span>(z) <span class="op">&lt;</span> <span class="dv">4</span></span>
<span id="b8cd3dee-17"><a href="#b8cd3dee-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> mask.<span class="bu">any</span>():</span>
<span id="b8cd3dee-18"><a href="#b8cd3dee-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="b8cd3dee-19"><a href="#b8cd3dee-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="b8cd3dee-20"><a href="#b8cd3dee-20" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> torch.where(mask, z <span class="op">*</span> z <span class="op">+</span> c, z)</span>
<span id="b8cd3dee-21"><a href="#b8cd3dee-21" aria-hidden="true" tabindex="-1"></a>        iter_counts <span class="op">=</span> torch.where(mask, iter_counts <span class="op">+</span> <span class="dv">1</span>, iter_counts)</span>
<span id="b8cd3dee-22"><a href="#b8cd3dee-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="b8cd3dee-23"><a href="#b8cd3dee-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> iter_counts</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Because we are using <code>pytorch</code> tensors, we can offload the workload onto a GPU by setting the <code>device</code> parameter to <code>'cuda'</code> or <code>'mps'</code>. This tells <code>pytorch</code> to use the GPU for all subsequent operations, which will significantly speed up the computation. The rest of the code remains the same, with the same vectorized operations and conditional updates as in the NumPy version.</p>
<p>The difference being that when using the GPU, the operations will run concurrently on the GPU cores, which are optimized for parallel computation. For example, when running <code>z = torch.where(mask, z * z + c, z)</code> on a GPU, each element in <code>z</code>, <code>mask</code>, and <code>c</code> can be processed simultaneously by different cores, allowing for massive speedups compared to sequential execution on a CPU. Effectivelly we will be “painting” the Mandelbrot set in one single operation rather than pixel by pixel.</p>
</section>
<section id="apples-mlx" class="level3">
<h3 class="anchored" data-anchor-id="apples-mlx">Apple’s MLX</h3>
<p>Apple’s MLX offers an API which is virtually the same as PyTorch and NumPy, and it can be used interchangeably with them. The only difference is that it is optimized for Apple hardware, and it can be used on Apple Silicon.</p>
<div id="eab842b5" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="eab842b5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="eab842b5-1"><a href="#eab842b5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mlx.core <span class="im">as</span> mx</span>
<span id="eab842b5-2"><a href="#eab842b5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="eab842b5-3"><a href="#eab842b5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="eab842b5-4"><a href="#eab842b5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_mandelbrot_mlx(</span>
<span id="eab842b5-5"><a href="#eab842b5-5" aria-hidden="true" tabindex="-1"></a>    width: <span class="bu">int</span> <span class="op">=</span> <span class="dv">500</span>, height: <span class="bu">int</span> <span class="op">=</span> <span class="dv">500</span>, max_iter: <span class="bu">int</span> <span class="op">=</span> <span class="dv">30</span></span>
<span id="eab842b5-6"><a href="#eab842b5-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> mx.array:</span>
<span id="eab842b5-7"><a href="#eab842b5-7" aria-hidden="true" tabindex="-1"></a>    real <span class="op">=</span> mx.linspace(<span class="op">-</span><span class="dv">2</span>, <span class="dv">1</span>, width)</span>
<span id="eab842b5-8"><a href="#eab842b5-8" aria-hidden="true" tabindex="-1"></a>    imag <span class="op">=</span> mx.linspace(<span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.5</span>, height)</span>
<span id="eab842b5-9"><a href="#eab842b5-9" aria-hidden="true" tabindex="-1"></a>    X, Y <span class="op">=</span> mx.meshgrid(real, imag, indexing<span class="op">=</span><span class="st">"xy"</span>)</span>
<span id="eab842b5-10"><a href="#eab842b5-10" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> X <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> Y</span>
<span id="eab842b5-11"><a href="#eab842b5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="eab842b5-12"><a href="#eab842b5-12" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> mx.zeros_like(c)</span>
<span id="eab842b5-13"><a href="#eab842b5-13" aria-hidden="true" tabindex="-1"></a>    iter_counts <span class="op">=</span> mx.zeros(c.shape, dtype<span class="op">=</span>mx.int32)</span>
<span id="eab842b5-14"><a href="#eab842b5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="eab842b5-15"><a href="#eab842b5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="eab842b5-16"><a href="#eab842b5-16" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> mx.<span class="bu">abs</span>(z) <span class="op">&lt;</span> <span class="dv">4</span></span>
<span id="eab842b5-17"><a href="#eab842b5-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> mask.<span class="bu">any</span>():</span>
<span id="eab842b5-18"><a href="#eab842b5-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="eab842b5-19"><a href="#eab842b5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="eab842b5-20"><a href="#eab842b5-20" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> mx.where(mask, z <span class="op">*</span> z <span class="op">+</span> c, z)</span>
<span id="eab842b5-21"><a href="#eab842b5-21" aria-hidden="true" tabindex="-1"></a>        iter_counts <span class="op">=</span> mx.where(mask, iter_counts <span class="op">+</span> <span class="dv">1</span>, iter_counts)</span>
<span id="eab842b5-22"><a href="#eab842b5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="eab842b5-23"><a href="#eab842b5-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> iter_counts</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="putting-it-all-together" class="level2">
<h2 class="anchored" data-anchor-id="putting-it-all-together">Putting it all together</h2>
<p>Let’s put all the above together and render the Mandelbrot set with each different method. Each of <code>compute_mandelbrot_*</code> returns a 2D array of integers, where each integer represents the number of iterations it took for that pixel to diverge. We will then use <code>matplotlib</code> to render the image.</p>
<div id="9f10a0d6" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="9f10a0d6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="9f10a0d6-1"><a href="#9f10a0d6-1" aria-hidden="true" tabindex="-1"></a>mps_available <span class="op">=</span> torch.backends.mps.is_available()</span>
<span id="9f10a0d6-2"><a href="#9f10a0d6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="9f10a0d6-3"><a href="#9f10a0d6-3" aria-hidden="true" tabindex="-1"></a>width, height <span class="op">=</span> <span class="dv">500</span>, <span class="dv">500</span></span>
<span id="9f10a0d6-4"><a href="#9f10a0d6-4" aria-hidden="true" tabindex="-1"></a>max_iter <span class="op">=</span> <span class="dv">30</span></span>
<span id="9f10a0d6-5"><a href="#9f10a0d6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="9f10a0d6-6"><a href="#9f10a0d6-6" aria-hidden="true" tabindex="-1"></a>iter_counts <span class="op">=</span> []</span>
<span id="9f10a0d6-7"><a href="#9f10a0d6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="9f10a0d6-8"><a href="#9f10a0d6-8" aria-hidden="true" tabindex="-1"></a>iter_counts_iterations <span class="op">=</span> compute_mandelbrot_iterations(width, height, max_iter)</span>
<span id="9f10a0d6-9"><a href="#9f10a0d6-9" aria-hidden="true" tabindex="-1"></a>iter_counts.append(iter_counts_iterations)</span>
<span id="9f10a0d6-10"><a href="#9f10a0d6-10" aria-hidden="true" tabindex="-1"></a>iter_counts_numpy <span class="op">=</span> compute_mandelbrot_numpy(width, height, max_iter)</span>
<span id="9f10a0d6-11"><a href="#9f10a0d6-11" aria-hidden="true" tabindex="-1"></a>iter_counts.append(iter_counts_numpy)</span>
<span id="9f10a0d6-12"><a href="#9f10a0d6-12" aria-hidden="true" tabindex="-1"></a>iter_counts_torch_cpu <span class="op">=</span> compute_mandelbrot_torch(width, height, max_iter, <span class="st">"cpu"</span>)</span>
<span id="9f10a0d6-13"><a href="#9f10a0d6-13" aria-hidden="true" tabindex="-1"></a>iter_counts.append(iter_counts_torch_cpu.T.cpu())</span>
<span id="9f10a0d6-14"><a href="#9f10a0d6-14" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mps_available:</span>
<span id="9f10a0d6-15"><a href="#9f10a0d6-15" aria-hidden="true" tabindex="-1"></a>    iter_counts_torch_mps <span class="op">=</span> compute_mandelbrot_torch(width, height, max_iter, <span class="st">"mps"</span>)</span>
<span id="9f10a0d6-16"><a href="#9f10a0d6-16" aria-hidden="true" tabindex="-1"></a>    iter_counts.append(iter_counts_torch_mps.T.cpu())</span>
<span id="9f10a0d6-17"><a href="#9f10a0d6-17" aria-hidden="true" tabindex="-1"></a>iter_counts_mlx <span class="op">=</span> compute_mandelbrot_mlx(width, height, max_iter)</span>
<span id="9f10a0d6-18"><a href="#9f10a0d6-18" aria-hidden="true" tabindex="-1"></a>iter_counts.append(iter_counts_mlx)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="plotting-the-set" class="level2">
<h2 class="anchored" data-anchor-id="plotting-the-set">Plotting the set</h2>
<p>Now let’s create a function to plot the above <code>iter_counts</code> list of Mandelbrot images so we can compare each visually, they should all look the same.</p>
<div id="47ba4c8c" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="47ba4c8c"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="47ba4c8c-1"><a href="#47ba4c8c-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="47ba4c8c-2"><a href="#47ba4c8c-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="47ba4c8c-3"><a href="#47ba4c8c-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="47ba4c8c-4"><a href="#47ba4c8c-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="47ba4c8c-5"><a href="#47ba4c8c-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_mandelbrot_grid(iter_counts_list: <span class="bu">list</span>, titles: <span class="bu">list</span> <span class="op">=</span> <span class="va">None</span>):</span>
<span id="47ba4c8c-6"><a href="#47ba4c8c-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(iter_counts_list)</span>
<span id="47ba4c8c-7"><a href="#47ba4c8c-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="47ba4c8c-8"><a href="#47ba4c8c-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"No Mandelbrot sets to plot."</span>)</span>
<span id="47ba4c8c-9"><a href="#47ba4c8c-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="47ba4c8c-10"><a href="#47ba4c8c-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="47ba4c8c-11"><a href="#47ba4c8c-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Determine grid dimensions (roughly square)</span></span>
<span id="47ba4c8c-12"><a href="#47ba4c8c-12" aria-hidden="true" tabindex="-1"></a>    n_cols <span class="op">=</span> math.ceil(math.sqrt(n))</span>
<span id="47ba4c8c-13"><a href="#47ba4c8c-13" aria-hidden="true" tabindex="-1"></a>    n_rows <span class="op">=</span> math.ceil(n <span class="op">/</span> n_cols)</span>
<span id="47ba4c8c-14"><a href="#47ba4c8c-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="47ba4c8c-15"><a href="#47ba4c8c-15" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(n_rows, n_cols, figsize<span class="op">=</span>(<span class="fl">2.5</span> <span class="op">*</span> n_cols, <span class="fl">2.5</span> <span class="op">*</span> n_rows))</span>
<span id="47ba4c8c-16"><a href="#47ba4c8c-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="47ba4c8c-17"><a href="#47ba4c8c-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Flatten axes array for easier iteration</span></span>
<span id="47ba4c8c-18"><a href="#47ba4c8c-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="47ba4c8c-19"><a href="#47ba4c8c-19" aria-hidden="true" tabindex="-1"></a>        axes <span class="op">=</span> [axes]</span>
<span id="47ba4c8c-20"><a href="#47ba4c8c-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="47ba4c8c-21"><a href="#47ba4c8c-21" aria-hidden="true" tabindex="-1"></a>        axes <span class="op">=</span> axes.flatten()</span>
<span id="47ba4c8c-22"><a href="#47ba4c8c-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="47ba4c8c-23"><a href="#47ba4c8c-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (ax, counts) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(axes, iter_counts_list)):</span>
<span id="47ba4c8c-24"><a href="#47ba4c8c-24" aria-hidden="true" tabindex="-1"></a>        ax.imshow(counts, cmap<span class="op">=</span><span class="st">"plasma"</span>, interpolation<span class="op">=</span><span class="st">"nearest"</span>, origin<span class="op">=</span><span class="st">"lower"</span>)</span>
<span id="47ba4c8c-25"><a href="#47ba4c8c-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use provided title if available, else default to "Mandelbrot"</span></span>
<span id="47ba4c8c-26"><a href="#47ba4c8c-26" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> titles[i] <span class="cf">if</span> titles <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> i <span class="op">&lt;</span> <span class="bu">len</span>(titles) <span class="cf">else</span> <span class="st">"Mandelbrot"</span></span>
<span id="47ba4c8c-27"><a href="#47ba4c8c-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add title text inside the plot at the top-left corner</span></span>
<span id="47ba4c8c-28"><a href="#47ba4c8c-28" aria-hidden="true" tabindex="-1"></a>        ax.text(</span>
<span id="47ba4c8c-29"><a href="#47ba4c8c-29" aria-hidden="true" tabindex="-1"></a>            <span class="fl">0.05</span>,</span>
<span id="47ba4c8c-30"><a href="#47ba4c8c-30" aria-hidden="true" tabindex="-1"></a>            <span class="fl">0.95</span>,</span>
<span id="47ba4c8c-31"><a href="#47ba4c8c-31" aria-hidden="true" tabindex="-1"></a>            title,</span>
<span id="47ba4c8c-32"><a href="#47ba4c8c-32" aria-hidden="true" tabindex="-1"></a>            transform<span class="op">=</span>ax.transAxes,</span>
<span id="47ba4c8c-33"><a href="#47ba4c8c-33" aria-hidden="true" tabindex="-1"></a>            color<span class="op">=</span><span class="st">"white"</span>,</span>
<span id="47ba4c8c-34"><a href="#47ba4c8c-34" aria-hidden="true" tabindex="-1"></a>            fontsize<span class="op">=</span><span class="dv">14</span>,</span>
<span id="47ba4c8c-35"><a href="#47ba4c8c-35" aria-hidden="true" tabindex="-1"></a>            verticalalignment<span class="op">=</span><span class="st">"top"</span>,</span>
<span id="47ba4c8c-36"><a href="#47ba4c8c-36" aria-hidden="true" tabindex="-1"></a>            bbox<span class="op">=</span><span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">"black"</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, edgecolor<span class="op">=</span><span class="st">"none"</span>),</span>
<span id="47ba4c8c-37"><a href="#47ba4c8c-37" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="47ba4c8c-38"><a href="#47ba4c8c-38" aria-hidden="true" tabindex="-1"></a>        ax.axis(<span class="st">"off"</span>)</span>
<span id="47ba4c8c-39"><a href="#47ba4c8c-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="47ba4c8c-40"><a href="#47ba4c8c-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Hide any unused subplots</span></span>
<span id="47ba4c8c-41"><a href="#47ba4c8c-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ax <span class="kw">in</span> axes[n:]:</span>
<span id="47ba4c8c-42"><a href="#47ba4c8c-42" aria-hidden="true" tabindex="-1"></a>        ax.axis(<span class="st">"off"</span>)</span>
<span id="47ba4c8c-43"><a href="#47ba4c8c-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="47ba4c8c-44"><a href="#47ba4c8c-44" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="47ba4c8c-45"><a href="#47ba4c8c-45" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div id="d4fa6b04" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="d4fa6b04"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="d4fa6b04-1"><a href="#d4fa6b04-1" aria-hidden="true" tabindex="-1"></a>plot_mandelbrot_grid(</span>
<span id="d4fa6b04-2"><a href="#d4fa6b04-2" aria-hidden="true" tabindex="-1"></a>    iter_counts,</span>
<span id="d4fa6b04-3"><a href="#d4fa6b04-3" aria-hidden="true" tabindex="-1"></a>    titles<span class="op">=</span>[</span>
<span id="d4fa6b04-4"><a href="#d4fa6b04-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Python (iterations)"</span>,</span>
<span id="d4fa6b04-5"><a href="#d4fa6b04-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">"NumPy"</span>,</span>
<span id="d4fa6b04-6"><a href="#d4fa6b04-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">"PyTorch (CPU)"</span>,</span>
<span id="d4fa6b04-7"><a href="#d4fa6b04-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"PyTorch (MPS)"</span> <span class="cf">if</span> mps_available <span class="cf">else</span> <span class="va">None</span>,</span>
<span id="d4fa6b04-8"><a href="#d4fa6b04-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Apple MLX"</span>,</span>
<span id="d4fa6b04-9"><a href="#d4fa6b04-9" aria-hidden="true" tabindex="-1"></a>    ],</span>
<span id="d4fa6b04-10"><a href="#d4fa6b04-10" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="index_files/figure-html/cell-8-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="index_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>That confirms that each of the methods above is correct, and that they all yield the same result. The only difference is the speed at which they compute the Mandelbrot set!</p>
</section>
<section id="timing-the-functions" class="level2">
<h2 class="anchored" data-anchor-id="timing-the-functions">Timing the functions</h2>
<p>So we can easily contrast and compare the speed of each of the above functions, let’s time them using the <code>time</code> module in Python at different resolutions (width and height). We will see the difference in parallelism between methods which rely entirely on the CPU and those which offload the computation to the GPU. All timings are in seconds.</p>
<div id="b334194e" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="b334194e"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="b334194e-1"><a href="#b334194e-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="b334194e-2"><a href="#b334194e-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-3"><a href="#b334194e-3" aria-hidden="true" tabindex="-1"></a>resolutions <span class="op">=</span> [<span class="dv">1000</span>, <span class="dv">2000</span>, <span class="dv">3000</span>, <span class="dv">4000</span>]</span>
<span id="b334194e-4"><a href="#b334194e-4" aria-hidden="true" tabindex="-1"></a>max_iter <span class="op">=</span> <span class="dv">1000</span></span>
<span id="b334194e-5"><a href="#b334194e-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-6"><a href="#b334194e-6" aria-hidden="true" tabindex="-1"></a>header <span class="op">=</span> [<span class="st">"Resolution"</span>, <span class="st">"Iterations"</span>, <span class="st">"NumPy"</span>, <span class="st">"PyTorch/cpu"</span>, <span class="st">"PyTorch/mps"</span>, <span class="st">"MLX"</span>]</span>
<span id="b334194e-7"><a href="#b334194e-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-8"><a href="#b334194e-8" aria-hidden="true" tabindex="-1"></a>table_data <span class="op">=</span> []</span>
<span id="b334194e-9"><a href="#b334194e-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-10"><a href="#b334194e-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> resolutions:</span>
<span id="b334194e-11"><a href="#b334194e-11" aria-hidden="true" tabindex="-1"></a>    width <span class="op">=</span> height <span class="op">=</span> n</span>
<span id="b334194e-12"><a href="#b334194e-12" aria-hidden="true" tabindex="-1"></a>    timings <span class="op">=</span> {}</span>
<span id="b334194e-13"><a href="#b334194e-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-14"><a href="#b334194e-14" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="b334194e-15"><a href="#b334194e-15" aria-hidden="true" tabindex="-1"></a>    compute_mandelbrot_iterations(width, height, max_iter)</span>
<span id="b334194e-16"><a href="#b334194e-16" aria-hidden="true" tabindex="-1"></a>    timings[<span class="st">"Iterations"</span>] <span class="op">=</span> time.time() <span class="op">-</span> start_time</span>
<span id="b334194e-17"><a href="#b334194e-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-18"><a href="#b334194e-18" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="b334194e-19"><a href="#b334194e-19" aria-hidden="true" tabindex="-1"></a>    compute_mandelbrot_numpy(width, height, max_iter)</span>
<span id="b334194e-20"><a href="#b334194e-20" aria-hidden="true" tabindex="-1"></a>    timings[<span class="st">"NumPy"</span>] <span class="op">=</span> time.time() <span class="op">-</span> start_time</span>
<span id="b334194e-21"><a href="#b334194e-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-22"><a href="#b334194e-22" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="b334194e-23"><a href="#b334194e-23" aria-hidden="true" tabindex="-1"></a>    compute_mandelbrot_torch(width, height, max_iter, <span class="st">"cpu"</span>)</span>
<span id="b334194e-24"><a href="#b334194e-24" aria-hidden="true" tabindex="-1"></a>    timings[<span class="st">"PyTorch/cpu"</span>] <span class="op">=</span> time.time() <span class="op">-</span> start_time</span>
<span id="b334194e-25"><a href="#b334194e-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-26"><a href="#b334194e-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> mps_available:</span>
<span id="b334194e-27"><a href="#b334194e-27" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="b334194e-28"><a href="#b334194e-28" aria-hidden="true" tabindex="-1"></a>        compute_mandelbrot_torch(width, height, max_iter, <span class="st">"mps"</span>)</span>
<span id="b334194e-29"><a href="#b334194e-29" aria-hidden="true" tabindex="-1"></a>        timings[<span class="st">"PyTorch/mps"</span>] <span class="op">=</span> time.time() <span class="op">-</span> start_time</span>
<span id="b334194e-30"><a href="#b334194e-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="b334194e-31"><a href="#b334194e-31" aria-hidden="true" tabindex="-1"></a>        timings[<span class="st">"PyTorch/mps"</span>] <span class="op">=</span> <span class="va">None</span></span>
<span id="b334194e-32"><a href="#b334194e-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-33"><a href="#b334194e-33" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="b334194e-34"><a href="#b334194e-34" aria-hidden="true" tabindex="-1"></a>    compute_mandelbrot_mlx(width, height, max_iter)</span>
<span id="b334194e-35"><a href="#b334194e-35" aria-hidden="true" tabindex="-1"></a>    timings[<span class="st">"MLX"</span>] <span class="op">=</span> time.time() <span class="op">-</span> start_time</span>
<span id="b334194e-36"><a href="#b334194e-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-37"><a href="#b334194e-37" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> [</span>
<span id="b334194e-38"><a href="#b334194e-38" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">x</span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>,</span>
<span id="b334194e-39"><a href="#b334194e-39" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"</span><span class="sc">{</span>timings[<span class="st">'Iterations'</span>]<span class="sc">:.3f}</span><span class="ss">"</span>,</span>
<span id="b334194e-40"><a href="#b334194e-40" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"</span><span class="sc">{</span>timings[<span class="st">'NumPy'</span>]<span class="sc">:.3f}</span><span class="ss">"</span>,</span>
<span id="b334194e-41"><a href="#b334194e-41" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"</span><span class="sc">{</span>timings[<span class="st">'PyTorch/cpu'</span>]<span class="sc">:.3f}</span><span class="ss">"</span>,</span>
<span id="b334194e-42"><a href="#b334194e-42" aria-hidden="true" tabindex="-1"></a>        (</span>
<span id="b334194e-43"><a href="#b334194e-43" aria-hidden="true" tabindex="-1"></a>            <span class="ss">f"</span><span class="sc">{</span>timings[<span class="st">'PyTorch/mps'</span>]<span class="sc">:.3f}</span><span class="ss">"</span></span>
<span id="b334194e-44"><a href="#b334194e-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> timings[<span class="st">"PyTorch/mps"</span>] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span></span>
<span id="b334194e-45"><a href="#b334194e-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="st">"N/A"</span></span>
<span id="b334194e-46"><a href="#b334194e-46" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="b334194e-47"><a href="#b334194e-47" aria-hidden="true" tabindex="-1"></a>        <span class="ss">f"</span><span class="sc">{</span>timings[<span class="st">'MLX'</span>]<span class="sc">:.3f}</span><span class="ss">"</span>,</span>
<span id="b334194e-48"><a href="#b334194e-48" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="b334194e-49"><a href="#b334194e-49" aria-hidden="true" tabindex="-1"></a>    table_data.append(row)</span>
<span id="b334194e-50"><a href="#b334194e-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="b334194e-51"><a href="#b334194e-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="sc">{:&lt;12}</span><span class="st"> </span><span class="sc">{:&lt;12}</span><span class="st"> </span><span class="sc">{:&lt;12}</span><span class="st"> </span><span class="sc">{:&lt;15}</span><span class="st"> </span><span class="sc">{:&lt;15}</span><span class="st"> </span><span class="sc">{:&lt;12}</span><span class="st">"</span>.<span class="bu">format</span>(<span class="op">*</span>header))</span>
<span id="b334194e-52"><a href="#b334194e-52" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> table_data:</span>
<span id="b334194e-53"><a href="#b334194e-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="sc">{:&lt;12}</span><span class="st"> </span><span class="sc">{:&lt;12}</span><span class="st"> </span><span class="sc">{:&lt;12}</span><span class="st"> </span><span class="sc">{:&lt;15}</span><span class="st"> </span><span class="sc">{:&lt;15}</span><span class="st"> </span><span class="sc">{:&lt;12}</span><span class="st">"</span>.<span class="bu">format</span>(<span class="op">*</span>row))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Resolution   Iterations   NumPy        PyTorch/cpu     PyTorch/mps     MLX         
1000x1000    19.987       5.667        2.689           0.514           0.394       
2000x2000    80.211       27.019       5.356           1.546           1.391       
3000x3000    175.523      68.376       17.918          3.094           2.884       
4000x4000    312.880      124.933      31.909          5.266           4.755       </code></pre>
</div>
</div>
<p>And finally let us put the above results in an intuitive visual representation, so we can see the difference in speed between the different methods.</p>
<div id="b1ebaf4b" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="b1ebaf4b"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="b1ebaf4b-1"><a href="#b1ebaf4b-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.ticker <span class="im">as</span> ticker</span>
<span id="b1ebaf4b-2"><a href="#b1ebaf4b-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="b1ebaf4b-3"><a href="#b1ebaf4b-3" aria-hidden="true" tabindex="-1"></a>resolutions_numeric <span class="op">=</span> [<span class="bu">int</span>(row[<span class="dv">0</span>].split(<span class="st">"x"</span>)[<span class="dv">0</span>]) <span class="cf">for</span> row <span class="kw">in</span> table_data]</span>
<span id="b1ebaf4b-4"><a href="#b1ebaf4b-4" aria-hidden="true" tabindex="-1"></a>methods <span class="op">=</span> header[<span class="dv">1</span>:]</span>
<span id="b1ebaf4b-5"><a href="#b1ebaf4b-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="b1ebaf4b-6"><a href="#b1ebaf4b-6" aria-hidden="true" tabindex="-1"></a>num_res <span class="op">=</span> <span class="bu">len</span>(resolutions_numeric)</span>
<span id="b1ebaf4b-7"><a href="#b1ebaf4b-7" aria-hidden="true" tabindex="-1"></a>num_methods <span class="op">=</span> <span class="bu">len</span>(methods)</span>
<span id="b1ebaf4b-8"><a href="#b1ebaf4b-8" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(num_res)  <span class="co"># x locations for the groups</span></span>
<span id="b1ebaf4b-9"><a href="#b1ebaf4b-9" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="fl">0.15</span>  <span class="co"># width of each bar</span></span>
<span id="b1ebaf4b-10"><a href="#b1ebaf4b-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="b1ebaf4b-11"><a href="#b1ebaf4b-11" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="b1ebaf4b-12"><a href="#b1ebaf4b-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="b1ebaf4b-13"><a href="#b1ebaf4b-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot bars for each method</span></span>
<span id="b1ebaf4b-14"><a href="#b1ebaf4b-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, method <span class="kw">in</span> <span class="bu">enumerate</span>(methods):</span>
<span id="b1ebaf4b-15"><a href="#b1ebaf4b-15" aria-hidden="true" tabindex="-1"></a>    times <span class="op">=</span> []</span>
<span id="b1ebaf4b-16"><a href="#b1ebaf4b-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> row <span class="kw">in</span> table_data:</span>
<span id="b1ebaf4b-17"><a href="#b1ebaf4b-17" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> row[i <span class="op">+</span> <span class="dv">1</span>]  <span class="co"># skip the resolution column</span></span>
<span id="b1ebaf4b-18"><a href="#b1ebaf4b-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use 0 for "N/A", or you could choose to skip/handle it differently</span></span>
<span id="b1ebaf4b-19"><a href="#b1ebaf4b-19" aria-hidden="true" tabindex="-1"></a>        times.append(<span class="bu">float</span>(value) <span class="cf">if</span> value <span class="op">!=</span> <span class="st">"N/A"</span> <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="b1ebaf4b-20"><a href="#b1ebaf4b-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate offset for each method within the group</span></span>
<span id="b1ebaf4b-21"><a href="#b1ebaf4b-21" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> (i <span class="op">-</span> num_methods <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> width <span class="op">+</span> width <span class="op">/</span> <span class="dv">2</span></span>
<span id="b1ebaf4b-22"><a href="#b1ebaf4b-22" aria-hidden="true" tabindex="-1"></a>    ax.bar(x <span class="op">+</span> offset, times, width, label<span class="op">=</span>method)</span>
<span id="b1ebaf4b-23"><a href="#b1ebaf4b-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="b1ebaf4b-24"><a href="#b1ebaf4b-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Set labels and ticks</span></span>
<span id="b1ebaf4b-25"><a href="#b1ebaf4b-25" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="st">"Resolution (pixels)"</span>)</span>
<span id="b1ebaf4b-26"><a href="#b1ebaf4b-26" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="st">"Time (s)"</span>)</span>
<span id="b1ebaf4b-27"><a href="#b1ebaf4b-27" aria-hidden="true" tabindex="-1"></a>ax.set_xticks(x)</span>
<span id="b1ebaf4b-28"><a href="#b1ebaf4b-28" aria-hidden="true" tabindex="-1"></a>ax.set_xticklabels([<span class="ss">f"</span><span class="sc">{</span>res<span class="sc">}</span><span class="ss">x</span><span class="sc">{</span>res<span class="sc">}</span><span class="ss">"</span> <span class="cf">for</span> res <span class="kw">in</span> resolutions_numeric])</span>
<span id="b1ebaf4b-29"><a href="#b1ebaf4b-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="b1ebaf4b-30"><a href="#b1ebaf4b-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Disable scientific notation on the y-axis</span></span>
<span id="b1ebaf4b-31"><a href="#b1ebaf4b-31" aria-hidden="true" tabindex="-1"></a>formatter <span class="op">=</span> ticker.ScalarFormatter()</span>
<span id="b1ebaf4b-32"><a href="#b1ebaf4b-32" aria-hidden="true" tabindex="-1"></a>formatter.set_scientific(<span class="va">False</span>)</span>
<span id="b1ebaf4b-33"><a href="#b1ebaf4b-33" aria-hidden="true" tabindex="-1"></a>ax.yaxis.set_major_formatter(formatter)</span>
<span id="b1ebaf4b-34"><a href="#b1ebaf4b-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="b1ebaf4b-35"><a href="#b1ebaf4b-35" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="b1ebaf4b-36"><a href="#b1ebaf4b-36" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><a href="index_files/figure-html/cell-10-output-1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="index_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></a></p>
</figure>
</div>
</div>
</div>
<p>You can see that GPU methods are significantly faster than the CPU because of its inherent parallelism. The more cores you have, the faster the computation will be. This is why GPUs are so good at parallel workloads, and why they are so adept to machine learning and AI workloads - deep down, they are just matrix operations using embarrasingly parallel workloads.</p>


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/pedroleitao\.nl");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2025 Pedro Leitão</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with Quarto</p>
</div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>