{
  "hash": "cde573723b2d426d2ac2a671a0bc6fab",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Types of Data\nsubtitle: basic and advanced data types in Python\njupyter: python3\norder: 5\nformat:\n  html:\n    code-fold: false\n---\n\n\n\nPython has a number of basic types of data. These include integers, floating point numbers, strings, lists and booleans. With different types of data, you can do different things. For example, you can add two integers or floating point numbers, you can concatenate strings, check booleans (True or False) and so on.\n\nData is the life and blood of any program. It is the data that we manipulate and process to get the desired output. In Python, data is stored in variables. A variable is a name that refers to a value. You can think of a variable as a box that holds data. You can put data into a variable and then refer to the data by the variable's name.\n\n\n## Basic data types\n\nPython supports a number of basic data types. These are:\n\n1. Integers\n2. Floating point numbers\n3. Strings\n4. Booleans\n\nHere are some examples of each of these data types:\n\n::: {#673ed436 .cell execution_count=2}\n``` {.python .cell-code}\na = 1 # This is an integer\nb = 2.0 # This is a float\nc = \"Hello\" # This is a string\nd = True # This is a boolean\n```\n:::\n\n\nStrings are sequences of characters or text. You can create a string by enclosing text in single or double quotes. For example:\n\n::: {#d933cb42 .cell execution_count=3}\n``` {.python .cell-code}\nc = \"Hello\" # String with double quotes\nc = 'Hello' # String with single quotes\n```\n:::\n\n\nThe difference between single and double quotes is that you can use double quotes inside single quotes and vice versa. For example:\n\n::: {#96e7f10a .cell execution_count=4}\n``` {.python .cell-code}\nc = '\"Hello\"' # String with double quotes\nprint(c)\n\nc = \"'Hello'\" # String with single quotes\nprint(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\"Hello\"\n'Hello'\n```\n:::\n:::\n\n\n## Operators and basic data types\n\nPython supports a number of operators (`+`, `-`, `*`, `/`) that you can use with basic data types. For example, you can use the `+` operator to add two integers or floating point numbers, the `*` operator to multiply two integers or floating point numbers, the `+` operator to concatenate two strings, and so on. Here are some examples:\n\n::: {#76f39360 .cell execution_count=5}\n``` {.python .cell-code}\na = 2 + 3 # Addition\nprint(a)\n\na = 2 - 3 # Subtraction\nprint(a)\n\na = 2 * 3 # Multiplication\nprint(a)\n\na = 2 / 3 # Division\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n-1\n6\n0.6666666666666666\n```\n:::\n:::\n\n\nThese operators generally work as you would expect. But in some cases they might not make sense for some data types, for example, you can add two integers or two floating point numbers, but you can't add an integer and a string. You can add (concatenate) two strings, but you can't multiply two strings. You also can't, for example, add a numeric value to a string, or add two booleans.\n\n::: {#4d3cc8a0 .cell execution_count=6}\n``` {.python .cell-code}\na = 2 + 3 # This works fine\nprint(a)\n\na = 2 + \"3\" # This will give an error\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[44]</span><span class=\"ansi-green-fg\">, line 4</span>\n<span class=\"ansi-green-fg\">      1</span> a = <span class=\"ansi-green-fg\">2</span> + <span class=\"ansi-green-fg\">3</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># This works fine</span>\n<span class=\"ansi-green-fg\">      2</span> <span style=\"color:rgb(0,135,0)\">print</span>(a)\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">4</span> a = <span class=\"ansi-green-fg ansi-yellow-bg\">2</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-bg\">+</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-fg ansi-yellow-bg\">\"</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">3</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">\"</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># This will give an error</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: unsupported operand type(s) for +: 'int' and 'str'</pre>\n```\n:::\n\n:::\n:::\n\n\nThere are also some operators that work exclusively with booleans. For example, the `and` operator returns `True` if both operands are `True`, otherwise it returns `False`. The `or` operator returns `True` if at least one of the operands is `True`, otherwise it returns `False`. The `not` operator returns `True` if the operand is `False`, otherwise it returns `False`.\n\n::: {#44816262 .cell execution_count=7}\n``` {.python .cell-code}\na = True\nb = False\nc = a and b # Logical AND\nprint(c)\n\nc = a or b # Logical OR\nprint(c)\n\nc = not a # Logical NOT\nprint(c)\n\nc = a == b # Logical equals\nprint(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\nFalse\nFalse\n```\n:::\n:::\n\n\nThere are also some operators that work exclusively with integers. For example, the `//` operator returns the integer division of two integers, the `%` operator returns the remainder of the division of two integers, and the `**` operator returns the power of an integer.\n\n::: {#897a07e7 .cell execution_count=8}\n``` {.python .cell-code}\nc = 5 // 2 # Integer division\nprint(c)\n\nc = 5 % 2 # Modulus, returns the remainder\nprint(c)\n\nc = 5 ** 2 # Exponentiation\nprint(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n1\n25\n```\n:::\n:::\n\n\n### Converting between data types\n\nYou can convert between data types using the `int()`, `float()`, `str()`, and `bool()` functions, and some times this is necessary to make the data types compatible. For example, you can convert an integer to a floating point number, a floating point number to an integer, a string to an integer or floating point number, and so on.\n\nThis conversion is called type casting, and it is done by calling the appropriate function with the value you want to convert as an argument.\n\nHere are some examples:\n\n::: {#3aac1498 .cell execution_count=9}\n``` {.python .cell-code}\nc = int(5 / 2) # Type casting a float to an integer\nprint(c)\n\nc = float(5 * 2) # Type casting an integer to a float\nprint(c)\n\nc = str(5 / 2) # Type casting a float to a string\nprint(c)\n\nc = bool(1) # Type casting an integer to a boolean, 0 is False, everything else is True\nprint(c)\n\nc = int(\"5\") # Type casting a string to an integer\nprint(c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n10.0\n2.5\nTrue\n5\n```\n:::\n:::\n\n\n## More advanced data types\n\nBesides the basic data types, Python also supports more advanced data types. These include lists, tuples, dictionaries, and sets.\n\n* Lists are sequences of values.\n* Tuples are sequences of values that can't be changed.\n* Dictionaries are collections of key-value pairs.\n* Sets are collections of unique values.\n\n:::{.callout-note}\n## About the `type()` function\n\nYou can use the `type()` function to find out the type of a variable. For example, `type(1)` will return `<class 'int'>`, `type(1.0)` will return `<class 'float'>`, `type('hello')` will return `<class 'str'>`, and so on.\n:::\n\nLists, tuples, dictionaries and sets can hold any type of data, including other lists, tuples, dictionaries and sets. For example, you can have a list of lists, a dictionary of dictionaries, a list of integers, a list of integers and floats, etc.\n\nDictionaries are collections of key-value pairs. Key-value pairs are basically lists of \"this\" and \"that\". For example, you can have a dictionary with the keys \"name\" and \"age\" and the values \"John\" and 30. You can access the values of a dictionary by using the keys. For example, if you have a dictionary `person` with the keys \"name\" and \"age\", you can access the value of the key \"name\" by using `person['name']`.\n\n### Some examples of lists and tuples\n\nAdvanced types are more complex and abstract than basic types. They are used to store and manipulate more complex data structures, so let us look at a few examples of each of these types. Let us start with lists and tuples, as these are quite straightforward.\n\n::: {#ed41426e .cell execution_count=10}\n``` {.python .cell-code}\na = [1, 2, 3, 4, 5] # List\nprint(a)\n\na = (1, 2, 3, 4, 5) # Tuple\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5]\n(1, 2, 3, 4, 5)\n```\n:::\n:::\n\n\nHere we are creating a list and a tuple of integers. Note that we can mix different types of data, for example we can have integers, floats and strings in the same list or tuple.\n\n::: {#2b1c08c2 .cell execution_count=11}\n``` {.python .cell-code}\na = [1, 1.0, \"1\"] # List with mixed data types\nprint(a)\n\na = (1, 1.0, \"1\") # Tuple with mixed data types\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 1.0, '1']\n(1, 1.0, '1')\n```\n:::\n:::\n\n\nWe can even embed complex types within types. For example, we can have a list of lists.\n\n::: {#a1f3857d .cell execution_count=12}\n``` {.python .cell-code}\na = [\n    [1, 2],\n    [3, 4]\n] # List of lists\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1, 2], [3, 4]]\n```\n:::\n:::\n\n\nWe can access individual elements of complex types using indexing. We can also access **slices** of complex types using slicing. Slicing is a way to access a subset of a list, tuple, dictionary or set. Let us exemplify how this works.\n\n:::{.callout-note}\n## About Indexing\n\nIn Python, indexing starts at 0. So the first element of a list, tuple, dictionary or set is at index 0, the second element is at index 1, and so on. You can also use negative indices to access elements from the end of the list, tuple, dictionary or set. For example, the last element of a list is at index -1, the second to last element is at index -2, and so on.\n:::\n\n::: {#54274de0 .cell execution_count=13}\n``` {.python .cell-code}\na = [1, 2, 3, 4, 5]\nprint(a[0]) # Access the first element\nprint(a[1]) # Access the second element\nprint(a[-1]) # Access the last element\nprint(a[1:3]) # Access the second and third elements\nprint(a[1:]) # Access all elements starting from the second element\nprint(a[:3]) # Access the first three elements\n\n# For tuples this works the same way\na = (1, 2, 3, 4, 5)\nprint(a[0]) # Access the first element\nprint(a[1]) # Access the second element\nprint(a[-1]) # Access the last element\nprint(a[1:3]) # Access the second and third elements\nprint(a[1:]) # Access all elements starting from the second element\nprint(a[:3]) # Access the first three elements\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n5\n[2, 3]\n[2, 3, 4, 5]\n[1, 2, 3]\n1\n2\n5\n(2, 3)\n(2, 3, 4, 5)\n(1, 2, 3)\n```\n:::\n:::\n\n\nWe can also use this technique to modify elements of complex types. For example, we can change the value of an element in a list.\n\n::: {#af0faaa7 .cell execution_count=14}\n``` {.python .cell-code}\na = [1, 2, 3, 4, 5]\nprint(a)\n\na[0] = 10 # Change the first element\nprint(a)\n\n# Change the third and fourth elements\na[2:4] = [30, 40]\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5]\n[10, 2, 3, 4, 5]\n[10, 2, 30, 40, 5]\n```\n:::\n:::\n\n\nFor readibility, we can represent a list in multiple lines. This is useful when we have a long list in our code, for example:\n\n::: {#ae25bcac .cell execution_count=15}\n``` {.python .cell-code}\na = [1,\n     2,\n     3,\n     4,\n     5]\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5]\n```\n:::\n:::\n\n\nTuples are similar to lists, but they are immutable, which means that once you create a tuple, you can't change it. This makes tuples faster and more memory efficient than lists. As you've seen in previous examples, tuples are created by enclosing values in parentheses.\n\n::: {#dbb16a8c .cell execution_count=16}\n``` {.python .cell-code}\na = (1, 2, 3, 4, 5)\nprint(a)\n\n# This will give an error because tuples are immutable\na[0] = 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, 2, 3, 4, 5)\n```\n:::\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[54]</span><span class=\"ansi-green-fg\">, line 5</span>\n<span class=\"ansi-green-fg\">      2</span> <span style=\"color:rgb(0,135,0)\">print</span>(a)\n<span class=\"ansi-green-fg\">      4</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># This will give an error because tuples are immutable</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">5</span> <span class=\"ansi-yellow-bg\">a</span><span class=\"ansi-yellow-bg\">[</span><span class=\"ansi-green-fg ansi-yellow-bg\">0</span><span class=\"ansi-yellow-bg\">]</span> = <span class=\"ansi-green-fg\">10</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: 'tuple' object does not support item assignment</pre>\n```\n:::\n\n:::\n:::\n\n\n### Dictionaries and sets\n\nDictionaries are collections of key-value pairs. Keys are used to access values. Sets on the other hand are collections of unique values. Dictionaries specifically are very useful for storing data in a structured way and are used extensively in Python programming, as you learn, you will see how dictionaries are used in many different contexts.\n\nLet us first look at a simple example of a dictionary.\n\n::: {#b75882fe .cell execution_count=17}\n``` {.python .cell-code}\na = {}\na[\"John\"] = 25\na[\"Jane\"] = 30\na[\"Jack\"] = 35\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'John': 25, 'Jane': 30, 'Jack': 35}\n```\n:::\n:::\n\n\nHere we first create an empty dictionary and assign it to variable `a` with the expression `a = {}`. We then add key-value pairs to the dictionary using the syntax `a[key] = value`. We can access the value of a key using the syntax `a[key]`.\n\nWe can also create the dictionary with key-value pairs already in it. The above is equivalent to:\n\n::: {#16941980 .cell execution_count=18}\n``` {.python .cell-code}\na = {\n    \"John\": 25,\n    \"Jane\": 30,\n    \"Jack\": 35\n}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'John': 25, 'Jane': 30, 'Jack': 35}\n```\n:::\n:::\n\n\nWe can then access the values of the keys in the dictionary using the syntax `a[key]`.\n\n::: {#2ec90a75 .cell execution_count=19}\n``` {.python .cell-code}\nprint(a[\"John\"]) # Access the value for the key \"John\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25\n```\n:::\n:::\n\n\nDictionaries aren't immutable like tuples, so you can change the values of keys in a dictionary.\n\n::: {#918e96b1 .cell execution_count=20}\n``` {.python .cell-code}\na[\"John\"] = 26 # Change the value for the key \"John\"\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'John': 26, 'Jane': 30, 'Jack': 35}\n```\n:::\n:::\n\n\nDictionaries can also hold multiple types of data, including other dictionaries, lists, tuples, and sets. For example, you can have a dictionary of dictionaries, a dictionary of lists, a dictionary of tuples, and so on.\n\n::: {#a444fc26 .cell execution_count=21}\n``` {.python .cell-code}\na = {\n    \"John\": 25,\n    \"Jane\": 30,\n    \"Children\": {\n        \"Mary\": 3,\n        \"Paul\": 2\n    }\n}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'John': 25, 'Jane': 30, 'Children': {'Mary': 3, 'Paul': 2}}\n```\n:::\n:::\n\n\nDictionaries can have many types of nesting. For example, you can have a dictionary of dictionaries of lists of tuples of sets, and so on. Here is an example:\n\n::: {#44c2ad55 .cell execution_count=22}\n``` {.python .cell-code}\na = {\n    \"Family\": {\n        \"Father\": {\n            \"John\": 25\n        },\n        \"Mother\": {\n            \"Jane\": 30\n        },\n        \"Children\": {\n            \"Mary\": 3,\n            \"Paul\": 2\n        }\n    }\n}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'Family': {'Father': {'John': 25}, 'Mother': {'Jane': 30}, 'Children': {'Mary': 3, 'Paul': 2}}}\n```\n:::\n:::\n\n\nIn the above example notice how we created the dictionary `a` in a multi-line format, just as we did before with the list example. This is a common way to create dictionaries with many levels of nesting. It makes the code more readable and easier to understand.\n\nLet us now look at what a set is. A set is a collection of unique values. This means that a set can't have duplicate values. For example, if you try to add the same value to a set twice, the second value will be ignored. Here is an example of a set:\n\n::: {#dea4c779 .cell execution_count=23}\n``` {.python .cell-code}\na = {1, 2, 3, 4, 5}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1, 2, 3, 4, 5}\n```\n:::\n:::\n\n\nIf we try to create or add duplicate values to a set, the duplicates will be ignored.\n\n::: {#a9f2b82b .cell execution_count=24}\n``` {.python .cell-code}\na = {1, 1, 2, 2, 3, 3, 4, 4, 5, 5}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1, 2, 3, 4, 5}\n```\n:::\n:::\n\n\nNote however that sets are **unordered** and **unindexed**, which means that you can't access the values of a set using an index. You can only access the values of a set by iterating over the set. For example, trying the following will give an error:\n\n::: {#fc6a0605 .cell execution_count=25}\n``` {.python .cell-code}\na = {1, 2, 3, 4, 5}\nprint(a)\n\n # This will give an error because sets are unindexed\na[0] = 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1, 2, 3, 4, 5}\n```\n:::\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[63]</span><span class=\"ansi-green-fg\">, line 5</span>\n<span class=\"ansi-green-fg\">      2</span> <span style=\"color:rgb(0,135,0)\">print</span>(a)\n<span class=\"ansi-green-fg\">      4</span>  <span style=\"font-style:italic;color:rgb(95,135,135)\"># This will give an error because sets are unindexed</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">5</span> <span class=\"ansi-yellow-bg\">a</span><span class=\"ansi-yellow-bg\">[</span><span class=\"ansi-green-fg ansi-yellow-bg\">0</span><span class=\"ansi-yellow-bg\">]</span> = <span class=\"ansi-green-fg\">10</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: 'set' object does not support item assignment</pre>\n```\n:::\n\n:::\n:::\n\n\nTo add elements to a set instead you use the `add()` method. For example:\n\n::: {#b13782c0 .cell execution_count=26}\n``` {.python .cell-code}\na = {1, 2, 3, 4, 5}\nprint(a)\n\na.add(6) # Add an element to the set\nprint(a)\n\na.add(0)\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1, 2, 3, 4, 5}\n{1, 2, 3, 4, 5, 6}\n{0, 1, 2, 3, 4, 5, 6}\n```\n:::\n:::\n\n\nLike other complex data types, we can mix different types of data in a set. For example:\n\n::: {#6a4503ed .cell execution_count=27}\n``` {.python .cell-code}\na = {1, 2, 3, 4, 5}\nprint(a)\n\na.add(\"zero\")\nprint(a)\n\na.add('six')\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1, 2, 3, 4, 5}\n{1, 2, 3, 4, 5, 'zero'}\n{1, 2, 3, 4, 5, 'six', 'zero'}\n```\n:::\n:::\n\n\nSets, unlike lists and dictionaries, do not support lists, tuples or dictionaries as elements. This is because these types are unhashable, which means that they can't be used as keys in a dictionary or as elements in a set. For example, if you try to add a list to a set, you will get an error.\n\n::: {#7c675d06 .cell execution_count=28}\n``` {.python .cell-code}\na = {1, 2, 3, 4, 5}\nprint(a)\n\n# This will give an error because lists are unhashable\na.add(['zero', 'six'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1, 2, 3, 4, 5}\n```\n:::\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[66]</span><span class=\"ansi-green-fg\">, line 5</span>\n<span class=\"ansi-green-fg\">      2</span> <span style=\"color:rgb(0,135,0)\">print</span>(a)\n<span class=\"ansi-green-fg\">      4</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># This will give an error because lists are unhashable</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">5</span> <span class=\"ansi-yellow-bg\">a</span><span class=\"ansi-yellow-bg\">.</span><span class=\"ansi-yellow-bg\">add</span><span class=\"ansi-yellow-bg\">(</span><span class=\"ansi-yellow-bg\">[</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">'</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">zero</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">'</span><span class=\"ansi-yellow-bg\">,</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-fg ansi-yellow-bg\">'</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">six</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">'</span><span class=\"ansi-yellow-bg\">]</span><span class=\"ansi-yellow-bg\">)</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: unhashable type: 'list'</pre>\n```\n:::\n\n:::\n:::\n\n\n:::{.callout-note}\n## About Hashable Data Types\n\nA data type being `hashable` means that it can be converted to a unique integer value. For example, a string can be converted to a unique integer value, but a list can't. This is why lists, tuples and dictionaries can't be used as keys in a dictionary or as elements in a set. This is probably a bit too advanced for now, but it's good to know.\n:::\n\n### Special methods for complex types\n\nComplex types have special methods that you can use to manipulate them. For example, you can use the `append()` method to add an element to a list, the `remove()` method to remove an element from a list, the `pop()` method to remove and return an element from a list, the `clear()` method to remove all elements from a list, the `copy()` method to create a copy of a list, the `count()` method to count the number of occurrences of an element in a list, the `extend()` method to add the elements of a list to another list, the `index()` method to get the index of an element in a list, the `insert()` method to insert an element at a specific index in a list, the `reverse()` method to reverse the elements of a list, the `sort()` method to sort the elements of a list, and so on.\n\nLet us look at some examples of these methods.\n\n::: {#da1ec25c .cell execution_count=29}\n``` {.python .cell-code}\na = [1, 2, 3, 4, 5] # A list\nprint(a)\n\nprint(6 in a) # Check if an element is in the list\n\na.append(6) # Add an element to the list\nprint(a)\n\na.remove(6) # Remove an element from the list\nprint(a)\n\na = (1, 2, 3, 4, 5) # A tuple\nprint(a)\n\ni = a.index(3) # Find the index of an element in the tuple\nprint(i)\n\na = {\n    \"John\": 25,\n    \"Jane\": 30,\n    \"Jack\": 35\n}\nprint(a)\n\na.pop(\"John\") # Remove an element from the dictionary\nprint(a)\n\na.popitem() # Remove the last element from the dictionary\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5]\nFalse\n[1, 2, 3, 4, 5, 6]\n[1, 2, 3, 4, 5]\n(1, 2, 3, 4, 5)\n2\n{'John': 25, 'Jane': 30, 'Jack': 35}\n{'Jane': 30, 'Jack': 35}\n{'Jane': 30}\n```\n:::\n:::\n\n\n### Iterating over complex types\n\nAny complex type can be iterated over using a `for` loop. Loops are a way to repeat a block of code multiple times. For example, to go through a list of integers and add them up. Besides using a `for` loop, you can use other types of loops, such as `while` loops, which repeat a block of code as long as a condition is `True`.\n\nLet us exemplify this, by taking a list of integers, and summing them up.\n\n::: {#22ab680c .cell execution_count=30}\n``` {.python .cell-code}\na = [1, 2, 3, 4, 5]\nsum = 0\nfor element in a:\n    sum = sum + element\n\nprint(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n15\n```\n:::\n:::\n\n\nThe above pattern would work equally well with a tuple, dictionary or set. For example, to sum up the values of a dictionary, you can do the following:\n\n::: {#d1c2ac1d .cell execution_count=31}\n``` {.python .cell-code}\na = {\n    \"John\": 25,\n    \"Jane\": 30,\n    \"Jack\": 35\n}\nsum = 0\nfor key in a:\n    sum = sum + a[key]\n\nprint(sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n90\n```\n:::\n:::\n\n\nIn the above example, we are iterating over the keys of the dictionary `a` (where each is assigned to `key`, one per loop iteration) and summing up the values of the keys (where the value in each loop iteration is `a[key]`).\n\n:::{.callout-note}\n## About the `values()` Method\n\nAn alternative for the above dictionary example would be to use the `values()` method of the dictionary. This method returns a view of the values of the dictionary. For example, `a.values()` would return `[1, 2, 3]`. You can then iterate over the values of the dictionary as a list instead.\n:::\n\n### Converting between complex types\n\nJust as we can convert between basic data types, we can also convert between complex data types. For example, we can convert a list to a tuple, a tuple to a list, a list to a dictionary, a dictionary to a list, a list to a set, a set to a list, a dictionary to a set, a set to a dictionary, and so on.\n\nHere are some examples:\n\n::: {#18db1179 .cell execution_count=32}\n``` {.python .cell-code}\na = tuple([1, 2, 3, 4, 5]) # Convert a list to a tuple\nprint(a)\n\na = list((1, 2, 3, 4, 5)) # Convert a tuple to a list\nprint(a)\n\na = set([1, 2, 3, 4, 5]) # Convert a list to a set\nprint(a)\n\na = list({1, 2, 3, 4, 5}) # Convert a set to a list\nprint(a)\n\na = tuple({1, 2, 3, 4, 5}) # Convert a set to a tuple\nprint(a)\n\na = set((1, 2, 3, 4, 5)) # Convert a tuple to a set\nprint(a)\n\na = {\n    \"John\": 25,\n    \"Jane\": 30,\n    \"Jack\": 35\n}\n\nb = list(a.keys()) # Convert the keys of a dictionary to a list\nprint(b)\n\nb = list(a.values()) # Convert the values of a dictionary to a list\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, 2, 3, 4, 5)\n[1, 2, 3, 4, 5]\n{1, 2, 3, 4, 5}\n[1, 2, 3, 4, 5]\n(1, 2, 3, 4, 5)\n{1, 2, 3, 4, 5}\n['John', 'Jane', 'Jack']\n[25, 30, 35]\n```\n:::\n:::\n\n\n### Mutable object references\n\nUnlike basic data types, when you assign a variable to a complex type, you are actually assigning a reference to the object in memory. This means that if you assign a variable to another variable, you are actually assigning a reference to the same object in memory. This is important to understand, because if you modify the object through one variable, the changes will be reflected in the other variable as well.\n\nHere's an example to illustrate this:\n\n::: {#9b4dc539 .cell execution_count=33}\n``` {.python .cell-code}\na = 1\nb = a\na = 2\nprint(a,b)\n\na = [1, 2, 3, 4, 5]\nb = a\na[0] = 10\n\nprint(a,b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 1\n[10, 2, 3, 4, 5] [10, 2, 3, 4, 5]\n```\n:::\n:::\n\n\nIn the first part, we assigned 1 to `a`, `b` to `a`, and then changed the value of `a` to 2. This changed the value of `a` but not `b`, because `b` was assigned to `a` before the change.\n\nIn the second part we assigned `[1, 2, 3, 4, 5]` to `a`, then assigned `b` to `a`, and then changed the value of `a` by changing the first element of `a` to 10. This changed the value of `a` and `b`, because of object references. When you assign `b` to `a`, you are actually assigning a reference to the object in memory, so when you change the object through `a`, the changes are reflected in `b` as well!\n\nIf you want to avoid this behavior, you can create a copy of the object using the `copy()` method. For example:\n\n::: {#03bb305b .cell execution_count=34}\n``` {.python .cell-code}\na = [1, 2, 3, 4, 5]\nb = a.copy()\na[0] = 10\n\nprint(a,b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10, 2, 3, 4, 5] [1, 2, 3, 4, 5]\n```\n:::\n:::\n\n\nFor nested objects like a list of lists, you can use the `deepcopy()` method to create a deep copy of the object. For example:\n\n::: {#e2380e46 .cell execution_count=35}\n``` {.python .cell-code}\nimport copy\n\na = [\n    [1, 2],\n    [3, 4]\n]\nb = copy.deepcopy(a)\nb[0][0] = 10\nprint(a,b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1, 2], [3, 4]] [[10, 2], [3, 4]]\n```\n:::\n:::\n\n\nThe `deepcopy()` method creates a copy of the object and all of its nested objects. Had we used the `copy()` method instead, the nested objects would still be references to the original objects, and changes to the nested objects would be reflected in the copied object as well.\n\n:::{.callout-note}\nThis can be a bit non-intuitive at first, it is a good idea to create a few examples of your own to make sure you understand how this works.\n:::\n\n## Exercises\n\n1. How would you calculate and print half of pi ?\n2. Create a list of floats and print the list.\n3. Create a tuple of strings and print the tuple.\n4. Create a dictionary with the keys \"name\" and \"age\" and the values \"John\" and 30, and print the dictionary.\n5. Create a dictionary with a list of keys called \"name\" and \"age\", and a list of example values, and print the dictionary.\n6. You have a dictionary like `{\"marble\": 2, \"wood\": 3, \"stone\": 1}`. Write a program that uses the `values()` method of the dictionary to sum up the values of all the keys.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}