{
  "hash": "6dcf4c62e73612f1f6ed42e77d9ef075",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Caching long running jobs\nsubtitle: how to cache the results of long running computations in python\ndate: 2024-04-27\ntags: \n  - HowTo\n  - Python\n  - Caching\ncategogies:\n  - HowTo\n  - Python\n  - Machine Learning\njupyter: python3\n---\n\nIn any data science or machine learning pipeline, one often has to re-try and experiment with long running computations. For example, maybe you will be running some long running embeddings for thousands of text segments, or some long running hyperparameter search. In such cases, it is very useful to cache the results of these computations so that you don't have to re-run them every time you make a change to your code, just to wait potentially for hours.\n\nThis notebook demonstrates how to cache the results of long running code using the Python [`joblib`](https://joblib.readthedocs.io/en/stable/) library, which in the long term can save you a lot of time and hassle.\n\n\n## Why `joblib` ?\n\n`joblib` provides a simple interface for caching the results of any method call. It is very flexible and can be used to cache the results of methods which take multiple arguments, functions that return multiple values, and functions that return complex objects. There are alternatives to `joblib`, but in all honesty I have found it to be the simplest and quickest to spin-up. Your own experience may vary.\n\n## A simple example\n\nLet's start with a simple example. Suppose you have a function that takes a long time to run, and you want to cache the results of this function. To illustrate this, we will use the [Ulam Spiral](https://mathworld.wolfram.com/PrimeSpiral.html) as an example. The Ulam Spiral is a graphical depiction of the set of prime numbers, where the primes are arranged in a spiral. We will write a function that generates the Ulam Spiral for a given range of numbers, and cache the results of this function.\n\n::: {#bbb2e413 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\n\n# A function which computes all primes between two integers and returns them as a numpy array\n\ndef primes_between(a, b):\n    sieve = [True] * (b + 1)\n    sieve[0] = sieve[1] = False  # 0 and 1 are not prime numbers\n\n    for start in range(2, int(b**0.5) + 1):\n        if sieve[start]:\n            for multiple in range(start*start, b + 1, start):\n                sieve[multiple] = False\n\n    primes = np.array([num for num in range(a, b + 1) if sieve[num]])\n    return primes\n\n# Compute the Ulam Spiral and return it as a numpy array\n\ndef ulam_spiral(primes, a, b):\n    # Calculate the grid size n (smallest odd number greater than or equal to sqrt(b))\n    num_elements = b - a + 1\n    n = int(np.ceil(np.sqrt(num_elements)))\n    if n % 2 == 0:\n        n += 1\n\n    # Create an n x n grid\n    spiral = np.zeros((n, n), dtype=int)\n\n    # Convert the numpy array of primes to a set for O(1) membership testing\n    prime_set = set(primes)\n\n    x, y = n // 2, n // 2  # Start in the center of the grid\n    dx, dy = 0, -1         # Initial direction: up\n\n    for i in range(1, n * n + 1):\n        if a <= i <= b and i in prime_set:\n            spiral[x, y] = 1  # Mark the cell if it's a prime number\n\n        # Change direction if needed\n        if (x == y) or (x < y and x + y == n - 1) or (x > y and x + y == n):\n            dx, dy = -dy, dx\n\n        x, y = x + dx, y + dy\n\n    return spiral\n```\n:::\n\n\nRunning the `primes_between` and `ulam_spiral` generation functions can take significant time for large ranges of $\\mathbf{a}$ and $\\mathbf{b}$, and the goal is to cache the results so that you don't have to re-run it every time you make a change to your code. Let's illustrate this with an example of $\\mathbf{[1, 500000000]}$.\n\n::: {.callout-note}\nWe will zoom into the Ulam Spiral just to illustrate what it visually looks like, later on we will compute the entire spiral, which will take considerably longer.\n:::\n\n::: {#f8267f99 .cell execution_count=3}\n``` {.python .cell-code}\nimport time\n\n# Compute all primes\nstart_time = time.time()\na = 1\nb = 500000000\nprimes = primes_between(a, b)\nend_time = time.time()\nprint(f'Number of primes between {a} and {b}: {len(primes)}')\nprint(\"Time taken: \", end_time - start_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of primes between 1 and 500000000: 26355867\nTime taken:  27.11750555038452\n```\n:::\n:::\n\n\n::: {#95a23e20 .cell execution_count=4}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Generate Ulam Spiral\nstart_time = time.time()\nzoom_b = b/10000\nspiral = ulam_spiral(primes, a, zoom_b)\nend_time = time.time()\nprint(\"Time taken: \", end_time - start_time)\n\n# Plot Ulam Spiral\nplt.figure(figsize=(8, 8))\nplt.imshow(spiral, cmap='Oranges', extent=[0, spiral.shape[0], 0, spiral.shape[1]])\nplt.title(f'Ulam Spiral of Primes Between {a} and {zoom_b}')\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime taken:  4.255573511123657\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-2.png){}\n:::\n:::\n\n\n## Wrapping methods with `joblib`\n\nLet us wrap the `ulam_spiral` and `primes_between` methods with joblib's `Memory` class. This will allow us to cache the results, so that we don't have to re-run any given combination of parameters every time we make a change to our code. To do this, we will just use `joblib`'s annotation `@memory.cache` before the method definition.\n\n::: {#5d41eb6e .cell execution_count=5}\n``` {.python .cell-code}\n# Wrap the 'ulam_spiral' method call with joblib's 'Memory' class\n\nfrom joblib import Memory\n\nmemory = Memory(location='/tmp', verbose=0)\n\n@memory.cache\ndef ulam_spiral_cached(primes, a, b):\n    return ulam_spiral(primes, a, b)\n\n@memory.cache\ndef primes_between_cached(a, b):\n    return primes_between(a, b)\n```\n:::\n\n\n::: {#208cb3e1 .cell execution_count=6}\n``` {.python .cell-code}\n# Compute all primes\nstart_time = time.time()\nprimes = primes_between_cached(a, b)\nend_time = time.time()\nprint(\"Time taken: \", end_time - start_time)\n\n# Run it again\nstart_time = time.time()\nprimes = primes_between_cached(a, b)\nend_time = time.time()\nprint(\"Time taken (cached): \", end_time - start_time)\n\n# Generate Ulam Spiral\nstart_time = time.time()\nspiral = ulam_spiral_cached(primes, a, b)\nend_time = time.time()\nprint(\"Time taken: \", end_time - start_time)\n\n# Run it again\nstart_time = time.time()\nspiral = ulam_spiral_cached(primes, a, b)\nend_time = time.time()\nprint(\"Time taken (cached): \", end_time - start_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime taken:  27.78532600402832\nTime taken (cached):  0.03455686569213867\nTime taken:  56.73884630203247\nTime taken (cached):  0.9918622970581055\n```\n:::\n:::\n\n\nNotice how in the second run, the method is not re-computed, instead results are loaded from the cache, significantly reducing the time taken to run the method.\n\n## Special considerations\n\nWhen using `joblib` to cache the results of a method, there are a few things to keep in mind, or else the caching will not work as expected:\n\n1. The method must be deterministic, that is, it must return the same output for the same input every time it is run.\n2. It must be serializable, that is, it must be able to be pickled.\n3. It must not have any side-effects, that is, it must not modify any global state or have any side-effects.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}